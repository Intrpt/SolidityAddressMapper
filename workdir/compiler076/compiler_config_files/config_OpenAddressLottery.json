{
  "language": "Solidity",
  "settings": {
    "debug": {
      "revertStrings": "debug"
    },
    "optimizer": {
      "enabled": false
    },
    "viaIR": false,
    "evmVersion": "istanbul",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "modelChecker": {
      "engine": "none",
      "timeout": 0
    },
    "outputSelection": {
      "*": {
        "": [
          "*"
        ],
        "*": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "compiler076/OpenAddressLottery.sol": {
      "content": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\n * @vulnerable_at_lines: 93\n */\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    constructor() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() public payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>address(this).balance) //if the balance isnt sufficient...\n                win=address(this).balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) public view returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\n    }\n    \n    function reseed(SeedComponents memory components) internal {\n        secretSeed = uint256(keccak256(abi.encodePacked(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() public {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents memory s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n"
    }
  }
}