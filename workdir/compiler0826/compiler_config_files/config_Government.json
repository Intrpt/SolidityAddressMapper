{
  "language": "Solidity",
  "settings": {
    "debug": {
      "revertStrings": "debug",
      "debugInfo": [
        "*"
      ]
    },
    "optimizer": {
      "enabled": false
    },
    "viaIR": false,
    "evmVersion": "cancun",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true,
      "appendCBOR": true
    },
    "modelChecker": {
      "engine": "none",
      "invariants": [
        "contract",
        "reentrancy"
      ],
      "showUnproved": true,
      "showUnsupported": true,
      "timeout": 0
    },
    "outputSelection": {
      "*": {
        "": [
          "*"
        ],
        "*": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "Government.sol": {
      "content": "/*\r\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\r\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\r\n * @author: -\r\n * @vulnerable_at_lines: 47,49\r\n */\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ncontract Government {\r\n\r\n     // Global Variables\r\n     uint32 public lastCreditorPayedOut;\r\n     uint public lastTimeOfNewCredit;\r\n     uint public profitFromCrash;\r\n     address payable[] public creditorAddresses;\r\n     uint[] public creditorAmounts;\r\n     address payable public corruptElite;\r\n     mapping (address => uint) buddies;\r\n     uint constant TWELVE_HOURS = 43200;\r\n     uint8 public round;\r\n\r\n     constructor() payable {\r\n         // The corrupt elite establishes a new government\r\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\r\n         profitFromCrash = msg.value;\r\n         corruptElite = payable(msg.sender);\r\n         lastTimeOfNewCredit = block.timestamp;\r\n     }\r\n\r\n     function lendGovernmentMoney(address payable buddy) public payable returns (bool) {\r\n         uint amount = msg.value;\r\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\r\n         // 12h are on average = 60*60*12/12.5 = 3456\r\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\r\n             // Return money to sender\r\n             payable(msg.sender).send(amount);\r\n             // Sends all contract money to the last creditor\r\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\r\n             corruptElite.send(address(this).balance);\r\n             // Reset contract state\r\n             lastCreditorPayedOut = 0;\r\n             lastTimeOfNewCredit = block.timestamp;\r\n             profitFromCrash = 0;\r\n            // <yes> <report> DENIAL_OF_SERVICE\r\n             creditorAddresses = new address payable[](0);\r\n            // <yes> <report> DENIAL_OF_SERVICE\r\n             creditorAmounts = new uint[](0);\r\n             round += 1;\r\n             return false;\r\n         }\r\n         else {\r\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\r\n             if (amount >= 10 ** 18) {\r\n                 // the System has received fresh money, it will survive at leat 12h more\r\n                 lastTimeOfNewCredit = block.timestamp;\r\n                 // register the new creditor and his amount with 10% interest rate\r\n                 creditorAddresses.push(payable(msg.sender));\r\n                 creditorAmounts.push(amount * 110 / 100);\r\n                 // now the money is distributed\r\n                 // first the corrupt elite grabs 5% - thieves!\r\n                 corruptElite.send(amount * 5/100);\r\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\r\n                 if (profitFromCrash < 10000 * 10**18) {\r\n                     profitFromCrash += amount * 5/100;\r\n                 }\r\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\r\n                 // Make a deal with him.\r\n                 if(buddies[buddy] >= amount) {\r\n                     buddy.send(amount * 5/100);\r\n                 }\r\n                 buddies[msg.sender] += amount * 110 / 100;\r\n                 // 90% of the money will be used to pay out old creditors\r\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\r\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\r\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\r\n                     lastCreditorPayedOut += 1;\r\n                 }\r\n                 return true;\r\n             }\r\n             else {\r\n                 payable(msg.sender).send(amount);\r\n                 return false;\r\n             }\r\n         }\r\n     }\r\n\r\n     // fallback function\r\n     fallback() external payable {\r\n         lendGovernmentMoney(payable(address(0x0)));\r\n     }\r\n\r\n     function totalDebt() public view returns (uint debt) {\r\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\r\n             debt += creditorAmounts[i];\r\n         }\r\n     }\r\n\r\n     function totalPayedOut() public view returns (uint payout) {\r\n         for(uint i=0; i<lastCreditorPayedOut; i++){\r\n             payout += creditorAmounts[i];\r\n         }\r\n     }\r\n\r\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\r\n     function investInTheSystem() public payable {\r\n         profitFromCrash += msg.value;\r\n     }\r\n\r\n     // From time to time the corrupt elite inherits it's power to the next generation\r\n     function inheritToNextGeneration(address payable nextGeneration) public {\r\n         if (msg.sender == corruptElite) {\r\n             corruptElite = nextGeneration;\r\n         }\r\n     }\r\n\r\n     function getCreditorAddresses() public view returns (address payable[] memory) {\r\n         return creditorAddresses;\r\n     }\r\n\r\n     function getCreditorAmounts() public view returns (uint[] memory) {\r\n         return creditorAmounts;\r\n     }\r\n }\r\n"
    }
  }
}