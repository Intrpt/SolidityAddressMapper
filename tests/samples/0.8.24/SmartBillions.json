{"contracts":{"SmartBillions.sol":{"BasicToken":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"balance\":\"An uint representing the amount owned by the passed address.\"}},\"transfer(address,uint256)\":{\"details\":\"transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"BasicToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        payable(msg.sender).transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            payable(msg.sender).transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            payable(msg.sender).transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            payable(msg.sender).transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xdcda7ebdd967f24c4294aa1dafd507a90a37ebb12c9df873bc07c9b2fc72ef9d\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"ERC20":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"ERC20\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        payable(msg.sender).transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            payable(msg.sender).transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            payable(msg.sender).transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            payable(msg.sender).transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xdcda7ebdd967f24c4294aa1dafd507a90a37ebb12c9df873bc07c9b2fc72ef9d\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"ERC20Basic":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"ERC20Basic\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        payable(msg.sender).transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            payable(msg.sender).transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            payable(msg.sender).transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            payable(msg.sender).transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xdcda7ebdd967f24c4294aa1dafd507a90a37ebb12c9df873bc07c9b2fc72ef9d\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"SafeMath":{"evm":{"deployedBytecode":{"object":"73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fd6d2c7454f043ac5877655b0fb7c4d21bd7d9f3b7ea9f5000ec9fdc7b4f33ff64736f6c63430008180033","sourceMap":"320:244:0:-:0;;;;;;;;"}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"SafeMath\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        payable(msg.sender).transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            payable(msg.sender).transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            payable(msg.sender).transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            payable(msg.sender).transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xdcda7ebdd967f24c4294aa1dafd507a90a37ebb12c9df873bc07c9b2fc72ef9d\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"SmartBillions":{"evm":{"deployedBytecode":{"object":"60806040526004361061036f5760003560e01c8063814b3fe0116101c6578063c27509cf116100f7578063de46907111610095578063df1ead821161006f578063df1ead8214610ce8578063e4cc98a514610cff578063e73cc2eb14610d2a578063e76ece0114610d6757610370565b8063de46907114610c7b578063de88a34214610ca6578063df12b94e14610cbd57610370565b8063cd88333e116100d1578063cd88333e14610bd3578063d6d2500814610bfc578063d9fa933514610c27578063dd62ed3e14610c3e57610370565b8063c27509cf14610b73578063c416436514610b7d578063cd0a314b14610ba857610370565b8063a367d99a11610164578063b3470e971161013e578063b3470e9714610ae8578063bc85171814610b13578063be1eefbf14610b3e578063bfba902914610b4857610370565b8063a367d99a14610a6b578063a6f9dae114610a96578063a9059cbb14610abf57610370565b8063904d2248116101a0578063904d2248146109ce57806393e84cd914610a0b57806395d89b4114610a295780639ce962ca14610a5457610370565b8063814b3fe0146109295780638da5cb5b146109665780638eecddcf1461099157610370565b8063380f3087116102a0578063501895ae1161023e57806370a082311161021857806370a082311461085957806370ccd928146108965780637227c7ce146108c1578063785ce7ca146108ec57610370565b8063501895ae146107b457806366ce3bd2146107f15780636b4868181461082e57610370565b806340c73d171161027a57806340c73d171461070e578063413e90e7146107375780634288d7591461076057806343146f361461079d57610370565b8063380f3087146106695780633de8d340146106a65780633e43b652146106d157610370565b806318160ddd1161030d57806326699576116102e757806326699576146105b8578063313ce567146105e857806331c2b6e61461061357806337c430881461063e57610370565b806318160ddd1461053457806323b872dd1461055f5780632406e9fa1461058857610370565b8063095ea7b311610349578063095ea7b31461049e57806312c8052f146104c757806313e4b51f146104de57806316d190e31461050957610370565b806303f9c7931461042e57806306fdde031461044a5780630751076d1461047557610370565b5b60003411156103c357600160085411156103b4576103af600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16610d90565b6103be565b6103bc611657565b505b61042c565b600060085414801561041457506000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054115b156104235761042233611694565b5b61042b611a04565b5b005b61044860048036038101906104439190614a45565b610d90565b005b34801561045657600080fd5b5061045f6122d6565b60405161046c9190614b02565b60405180910390f35b34801561048157600080fd5b5061049c60048036038101906104979190614b5a565b61230f565b005b3480156104aa57600080fd5b506104c560048036038101906104c09190614b87565b612377565b005b3480156104d357600080fd5b506104dc611a04565b005b3480156104ea57600080fd5b506104f36124fd565b6040516105009190614be2565b60405180910390f35b34801561051557600080fd5b5061051e6125f6565b60405161052b9190614c0c565b60405180910390f35b34801561054057600080fd5b506105496125fc565b6040516105569190614c0c565b60405180910390f35b34801561056b57600080fd5b5061058660048036038101906105819190614c27565b612602565b005b6105a2600480360381019061059d9190614a45565b6128e1565b6040516105af9190614c0c565b60405180910390f35b6105d260048036038101906105cd9190614c7a565b61291f565b6040516105df9190614c0c565b60405180910390f35b3480156105f457600080fd5b506105fd612cde565b60405161060a9190614c0c565b60405180910390f35b34801561061f57600080fd5b50610628612ce3565b6040516106359190614cc9565b60405180910390f35b34801561064a57600080fd5b50610653612d09565b6040516106609190614c0c565b60405180910390f35b34801561067557600080fd5b50610690600480360381019061068b9190614b5a565b612d0f565b60405161069d9190614c0c565b60405180910390f35b3480156106b257600080fd5b506106bb612ded565b6040516106c89190614c0c565b60405180910390f35b3480156106dd57600080fd5b506106f860048036038101906106f39190614a45565b612e88565b6040516107059190614c0c565b60405180910390f35b34801561071a57600080fd5b5061073560048036038101906107309190614a45565b612f12565b005b34801561074357600080fd5b5061075e60048036038101906107599190614b5a565b613003565b005b34801561076c57600080fd5b5061078760048036038101906107829190614a45565b613032565b6040516107949190614c0c565b60405180910390f35b3480156107a957600080fd5b506107b2613270565b005b3480156107c057600080fd5b506107db60048036038101906107d69190614b5a565b6132eb565b6040516107e89190614c0c565b60405180910390f35b3480156107fd57600080fd5b5061081860048036038101906108139190614a45565b61330f565b6040516108259190614c0c565b60405180910390f35b34801561083a57600080fd5b5061084361339d565b6040516108509190614c0c565b60405180910390f35b34801561086557600080fd5b50610880600480360381019061087b9190614a45565b6133a3565b60405161088d9190614c0c565b60405180910390f35b3480156108a257600080fd5b506108ab6133ec565b6040516108b89190614c0c565b60405180910390f35b3480156108cd57600080fd5b506108d66133f9565b6040516108e39190614c0c565b60405180910390f35b3480156108f857600080fd5b50610913600480360381019061090e9190614a45565b6133ff565b6040516109209190614c0c565b60405180910390f35b34801561093557600080fd5b50610950600480360381019061094b9190614b5a565b613461565b60405161095d9190614c0c565b60405180910390f35b34801561097257600080fd5b5061097b613485565b6040516109889190614cc9565b60405180910390f35b34801561099d57600080fd5b506109b860048036038101906109b39190614a45565b6134ab565b6040516109c59190614c0c565b60405180910390f35b3480156109da57600080fd5b506109f560048036038101906109f09190614a45565b61350d565b604051610a029190614c0c565b60405180910390f35b610a13611657565b604051610a209190614c0c565b60405180910390f35b348015610a3557600080fd5b50610a3e61356f565b604051610a4b9190614b02565b60405180910390f35b348015610a6057600080fd5b50610a696135a8565b005b348015610a7757600080fd5b50610a806137d6565b604051610a8d9190614c0c565b60405180910390f35b348015610aa257600080fd5b50610abd6004803603810190610ab89190614a45565b6137dc565b005b348015610acb57600080fd5b50610ae66004803603810190610ae19190614b87565b6138cd565b005b348015610af457600080fd5b50610afd613c5a565b604051610b0a9190614c0c565b60405180910390f35b348015610b1f57600080fd5b50610b28613c6b565b604051610b359190614c0c565b60405180910390f35b610b46613c71565b005b348015610b5457600080fd5b50610b5d613c7b565b604051610b6a9190614c0c565b60405180910390f35b610b7b613c81565b005b348015610b8957600080fd5b50610b92613cae565b604051610b9f9190614c0c565b60405180910390f35b348015610bb457600080fd5b50610bbd613cb4565b604051610bca9190614c0c565b60405180910390f35b348015610bdf57600080fd5b50610bfa6004803603810190610bf59190614b5a565b613cba565b005b348015610c0857600080fd5b50610c11613e08565b604051610c1e9190614c0c565b60405180910390f35b348015610c3357600080fd5b50610c3c613e0e565b005b348015610c4a57600080fd5b50610c656004803603810190610c609190614ce4565b613f1b565b604051610c729190614c0c565b60405180910390f35b348015610c8757600080fd5b50610c90613fa2565b604051610c9d9190614c0c565b60405180910390f35b348015610cb257600080fd5b50610cbb613fa8565b005b348015610cc957600080fd5b50610cd2613fca565b604051610cdf9190614c0c565b60405180910390f35b348015610cf457600080fd5b50610cfd613fd0565b005b348015610d0b57600080fd5b50610d14614223565b604051610d219190614c0c565b60405180910390f35b348015610d3657600080fd5b50610d516004803603810190610d4c9190614a45565b614229565b604051610d5e9190614c0c565b60405180910390f35b348015610d7357600080fd5b50610d8e6004803603810190610d899190614b5a565b614287565b005b6001600854118015610dbc57506005614000610dac9190614d53565b600854610db99190614d95565b43105b8015610dcb5750600a54600954105b610dd457600080fd5b6000349050600954600a54610de99190614dc9565b811115610e7157600954600a54610e009190614dc9565b9050600a5460098190555060006008819055503373ffffffffffffffffffffffffffffffffffffffff166108fc610e40833461431790919063ffffffff16565b9081150290604051600060405180830381858888f19350505050158015610e6b573d6000803e3d6000fd5b50610e8b565b8060096000828254610e839190614d95565b925050819055505b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161480610f135750600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b1561103157600a81610f259190614e2c565b60076000828254610f369190614d95565b92505081905550600a81610f4a9190614e2c565b60056000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff16610fe29190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff160217905550611243565b600260646005836110429190614d53565b61104c9190614e2c565b6110569190614d53565b600760008282546110679190614d95565b92505081905550606460058261107d9190614d53565b6110879190614e2c565b60056000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1661111f9190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff16021790555060646005826111789190614d53565b6111829190614e2c565b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff166111f89190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055505b600b54600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601a6101000a81548161ffff021916908361ffff160217905550600066038d7ea4c68000826112b79190614e2c565b9050600067016345785d8a00006010846112d19190614d53565b6112db9190614e2c565b9050600067016345785d8a0000600a856112f59190614d53565b6112ff9190614e2c565b905082600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546113509190614d95565b925050819055508160036000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546113c89190614d95565b925050819055508060036000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546114409190614d95565b925050819055508082846114549190614d95565b61145e9190614d95565b60008082825461146e9190614d95565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040516114d39190614c0c565b60405180910390a3600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8460405161155b9190614c0c565b60405180910390a3600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516115e39190614c0c565b60405180910390a38473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f36a013c86c271c703c54dee591bc768e347954a0a9a1937dd17f5a29e9a8e645866040516116489190614c0c565b60405180910390a35050505050565b600061168f334360405160200161166f929190614f3a565b6040516020818303038152906040528051906020012060001c600061291f565b905090565b6000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601a9054906101000a900461ffff1661ffff1690506000600360008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054148061173b5750600081145b156117a557600b54600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601a6101000a81548161ffff021916908361ffff16021790555050611a01565b600b5481036117b45750611a01565b6000805463ffffffff600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546118079190614d53565b6118119190614e2c565b905060005b600b5483101561186457600c838154811061183457611833614f66565b5b90600052602060002001548261184a9190614d53565b816118559190614d95565b90508280600101935050611816565b63ffffffff816118749190614e2c565b905080600760008282546118889190614d95565b9250508190555080600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff166119069190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff16021790555082600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601a6101000a81548161ffff021916908361ffff1602179055508373ffffffffffffffffffffffffffffffffffffffff167fe1e87f40e4de2a6b68365d854f85940aad44d84933d399007702c6d340da445f82856040516119f5929190614f95565b60405180910390a25050505b50565b6000600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060600160405290816000820160009054906101000a900477ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1681526020016000820160189054906101000a900463ffffffff1663ffffffff1663ffffffff16815260200160008201601c9054906101000a900463ffffffff1663ffffffff1663ffffffff168152505090506000816040015163ffffffff1603611c3b576040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815250600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff160217905550905050506122d4565b6000816000015177ffffffffffffffffffffffffffffffffffffffffffffffff161480611c7257506001816040015163ffffffff16145b15611c8557611c7f6135a8565b506122d4565b806040015163ffffffff164311611c9b57600080fd5b43614000600a611cab9190614d53565b826040015163ffffffff16611cc09190614d95565b11611e42573373ffffffffffffffffffffffffffffffffffffffff167f770d64c654906ebab085526dd881064f61f0e5990caa94c94167eb29bc4645c6826040015143604051611d11929190615009565b60405180910390a26040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815250600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff160217905550905050506122d4565b6000806101008360400151611e579190615032565b63ffffffff16431015611e8b57826040015163ffffffff164060001c62ffffff169050611e84838261433e565b9150612074565b6000600e541115611ef457611ea9836040015163ffffffff16614585565b905063010000008163ffffffff1603611ee257826000015177ffffffffffffffffffffffffffffffffffffffffffffffff169150611eef565b611eec838261433e565b91505b612073565b3373ffffffffffffffffffffffffffffffffffffffff167f770d64c654906ebab085526dd881064f61f0e5990caa94c94167eb29bc4645c6846040015143604051611f40929190615009565b60405180910390a26040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815250600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff1602179055509050505050506122d4565b5b6040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815250600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff160217905550905050600082111561226f573373ffffffffffffffffffffffffffffffffffffffff167e362509948ea59afac5c6fa93fea5327b624bc705a6574f4e9f26e9d8bd7ccc846020015163ffffffff168363ffffffff16856040516121f99392919061506a565b60405180910390a2600d548211156122615781600d819055503373ffffffffffffffffffffffffffffffffffffffff167f955214d16f858518f04c701d01a6e2f5668548b6be3c6f2f0f8981f77f2cfc06836040516122589190614c0c565b60405180910390a25b61226a82614638565b6122d0565b3373ffffffffffffffffffffffffffffffffffffffff167f7375ed8230669ea9d64a9db629d7ce9501779604a67c95c0111377cf09f5b9b9846020015163ffffffff168363ffffffff166040516122c7929190614f95565b60405180910390a25b5050505b565b6040518060400160405280601381526020017f536d61727442696c6c696f6e7320546f6b656e0000000000000000000000000081525081565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461236d5761236c6150a1565b5b8060128190555050565b6000811415801561240557506000600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b15612413576124126150a1565b5b80600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040516124f19190614c0c565b60405180910390a35050565b600080600f54905060008114806125205750600a8161251c9190614d95565b4311155b1561252f5760009150506125f3565b60006101004310156125445760009050612555565b610100436125529190614dc9565b90505b80821015612581576000819050600a8161256f91906150d0565b8161257a9190614d95565b9050809250505b6000600a600e54846125939190614dc9565b61259d9190614e2c565b90506125a9838261485a565b6013614000836125b991906150d0565b815481106125ca576125c9614f66565b5b9060005260206000200181905550600a836125e59190614d95565b600f81905550600193505050505b90565b600d5481565b60005481565b60606004816126119190614d95565b60003690501015612625576126246150a1565b5b6000600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506126af85611694565b6126b884611694565b61270a83600360008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546149b690919063ffffffff16565b600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061279f83600360008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461431790919063ffffffff16565b600360008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506127f5838261431790919063ffffffff16565b600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040516128d29190614c0c565b60405180910390a35050505050565b600061291833436040516020016128f9929190614f3a565b6040516020818303038152906040528051906020012060001c8361291f565b9050919050565b6000612929611a04565b6000839050670de0b6b3a76400003411158015612947575060125434105b61295057600080fd5b6000341115612cc9576000600854036129a7576014346129709190614e2c565b600c600b548154811061298657612985614f66565b5b90600052602060002001600082825461299f9190614d95565b925050819055505b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614612ac85760006064346129ea9190614e2c565b905080600760008282546129fe9190614d95565b9250508190555080600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff16612a7c9190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff160217905550505b600343612ad59190614d95565b6010541015612afd57600343612aeb9190614d95565b60108190555034601181905550612b48565b6012546011541115612b2d5760106000815480929190612b1c90615101565b919050555034601181905550612b47565b3460116000828254612b3f9190614d95565b925050819055505b5b60405180606001604052803477ffffffffffffffffffffffffffffffffffffffffffffffff1681526020018262ffffff1663ffffffff16815260200160105463ffffffff16815250600660003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff1602179055509050503373ffffffffffffffffffffffffffffffffffffffff167f063f4540040cf99a22f577ef321c170763020e6277e47275ed9b3d17ec14e13d8262ffffff1660105434604051612cc09392919061506a565b60405180910390a25b612cd16124fd565b5060105491505092915050565b600081565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b61400081565b600080600e54148015612d225750600082115b8015612d3057506140008211155b612d3957600080fd5b600082601380549050612d4c9190614d95565b9050614000811115612d5e5761400090505b600060138054905090505b81811015612da8576013600190806001815401808255809150506001900390600052602060002001600090919091909150558080600101915050612d69565b5061400060138054905010612ddf57600a43612dc491906150d0565b43612dcf9190614dc9565b600e81905550600e54600f819055505b601380549050915050919050565b6000806008541115612e025760009050612e85565b6000614000600a612e139190614d53565b600e5443612e219190614dc9565b612e2b9190614e2c565b9050600b54811115612e41576000915050612e85565b614000600a612e509190614d53565b600e5443612e5e9190614dc9565b612e6891906150d0565b614000600a612e779190614d53565b612e819190614dc9565b9150505b90565b6000600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900477ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff169050919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612f7057612f6f6150a1565b5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603612fad57612fac6150a1565b5b612fb633611694565b612fbf81611694565b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60005b8181101561302d576130166124fd565b613020575061302f565b8080600101915050613006565b505b50565b600080600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060600160405290816000820160009054906101000a900477ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1681526020016000820160189054906101000a900463ffffffff1663ffffffff1663ffffffff16815260200160008201601c9054906101000a900463ffffffff1663ffffffff1663ffffffff168152505090506000816000015177ffffffffffffffffffffffffffffffffffffffffffffffff16148061316757506001816040015163ffffffff1611155b8061317b5750806040015163ffffffff1643105b806131a95750614000600a6131909190614d53565b816040015163ffffffff166131a59190614d95565b4310155b156131b857600091505061326b565b61010081604001516131ca9190615032565b63ffffffff164310156131f7576131ef81826040015163ffffffff164060001c61433e565b91505061326b565b6000600e541115613265576000613217826040015163ffffffff16614585565b905063010000008163ffffffff160361325257816000015177ffffffffffffffffffffffffffffffffffffffffffffffff169250505061326b565b61325c828261433e565b9250505061326b565b60009150505b919050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146132ce576132cd6150a1565b5b6003436132db9190614d95565b6010819055506000601181905550565b601381815481106132fb57600080fd5b906000526020600020016000915090505481565b6000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1679ffffffffffffffffffffffffffffffffffffffffffffffffffff169050919050565b600e5481565b6000600360008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b6000601380549050905090565b60105481565b6000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601c9054906101000a900463ffffffff1663ffffffff169050919050565b600c818154811061347157600080fd5b906000526020600020016000915090505481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601c9054906101000a900463ffffffff1663ffffffff169050919050565b6000600660008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160189054906101000a900463ffffffff1663ffffffff169050919050565b6040518060400160405280600481526020017f504c41590000000000000000000000000000000000000000000000000000000081525081565b6000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1679ffffffffffffffffffffffffffffffffffffffffffffffffffff16118015613694575043600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601c9054906101000a900463ffffffff1663ffffffff1611155b156137d4576000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1679ffffffffffffffffffffffffffffffffffffffffffffffffffff1690506000600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160006101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff16021790555080600760008282546137c29190614dc9565b925050819055506137d281614638565b505b565b60085481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461383a576138396150a1565b5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1603613877576138766150a1565b5b61388033611694565b61388981611694565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b60406004816138dc9190614d95565b600036905010156138f0576138ef6150a1565b5b6138f933611694565b61394b82600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461431790919063ffffffff16565b600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055503073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1603613b51576139ec600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16611694565b613a608260036000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546149b690919063ffffffff16565b60036000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051613b449190614c0c565b60405180910390a3613c55565b613b5a83611694565b613bac82600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546149b690919063ffffffff16565b600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef84604051613c4c9190614c0c565b60405180910390a35b505050565b6000613c666080612d0f565b905090565b600f5481565b613c79613e0e565b565b60125481565b613cac600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16610d90565b565b600a5481565b60075481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613d1857613d176150a1565b5b613d20613e0e565b600081118015613d61575080600754600a60098054613d3f9190614d53565b613d499190614e2c565b613d539190614d95565b613d5d9190614d95565b4710155b613d6a57600080fd5b6002600a54613d799190614e2c565b60095410613db75761019047613d8f9190614e2c565b8111158015613dad575043619d80601454613daa9190614d95565b11155b613db657600080fd5b5b3373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f19350505050158015613dfd573d6000803e3d6000fd5b504360148190555050565b60145481565b6001600854118015613e3b57506005614000613e2a9190614d53565b600854613e379190614d95565b4310155b15613e4d576000600881905550613f19565b6000600e541115613f18576000614000600a613e699190614d53565b600e5443613e779190614dc9565b613e819190614e2c565b90506002600c80549050613e959190614dc9565b811115613ec757600c600090806001815401808255809150506001900390600052602060002001600090919091909150555b600b5481118015613eda57506000600854145b8015613ef857506001600c80549050613ef39190614dc9565b600b54105b15613f1657600b6000815480929190613f1090615101565b91905055505b505b5b565b6000600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b60115481565b600060085414613fb757600080fd5b613fc033611694565b613fc86135a8565b565b60095481565b600060085414613fdf57600080fd5b613fe833611694565b600066038d7ea4c68000600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461403c9190614d53565b9050600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546040516140db9190614c0c565b60405180910390a3600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000905580600960008282546141389190614dc9565b92505081905550600a60098261414e9190614d53565b6141589190614e2c565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff166141ce9190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055506142206135a8565b50565b600b5481565b6000600560008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601a9054906101000a900461ffff1661ffff169050919050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146142e5576142e46150a1565b5b60016008541480156142f957506000600e54115b801561430457508043105b61430d57600080fd5b8060088190555050565b60008282111561432a576143296150a1565b5b81836143369190614dc9565b905092915050565b600080836020015190506000838218905060008062f00000831662ffffff161461436957600061436c565b60015b6000620f0000841662ffffff1614614385576000614388565b60015b600061f000851662ffffff16146143a05760006143a3565b60015b6000610f00861662ffffff16146143bb5760006143be565b60015b600060f0871662ffffff16146143d55760006143d8565b60015b6000600f881662ffffff16146143ef5760006143f2565b60015b6143fc9190615156565b6144069190615156565b6144109190615156565b61441a9190615156565b6144249190615156565b60ff16905060068162ffffff160361446d57626acfc0866000015177ffffffffffffffffffffffffffffffffffffffffffffffff166144639190614d53565b935050505061457f565b60058162ffffff16036144b057614e20866000015177ffffffffffffffffffffffffffffffffffffffffffffffff166144a69190614d53565b935050505061457f565b60048162ffffff16036144f3576101f4866000015177ffffffffffffffffffffffffffffffffffffffffffffffff166144e99190614d53565b935050505061457f565b60038162ffffff1603614535576019866000015177ffffffffffffffffffffffffffffffffffffffffffffffff1661452b9190614d53565b935050505061457f565b60028162ffffff1603614577576003866000015177ffffffffffffffffffffffffffffffffffffffffffffffff1661456d9190614d53565b935050505061457f565b600093505050505b92915050565b600080600a600e54846145989190614dc9565b6145a29190614e2c565b905060006013614000836145b691906150d0565b815481106145c7576145c6614f66565b5b9060005260206000200154905060f081901c614000836145e79190614e2c565b146145fa57630100000092505050614633565b6000600a600e548661460c9190614dc9565b61461691906150d0565b905062ffffff8160186146299190614d53565b83901c1693505050505b919050565b60006002476146479190614e2c565b90508181106146b4573373ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015614696573d6000803e3d6000fd5b5066038d7ea4c680008211156146af576146ae613e0e565b5b614856565b600081836146c29190614dc9565b905080600760008282546146d69190614d95565b9250508190555080600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff166147549190614e83565b92506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055506202a300436147ad9190614d95565b600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600001601c6101000a81548163ffffffff021916908363ffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015614853573d6000803e3d6000fd5b50505b5050565b600060f06140008363ffffffff166148729190614e2c565b901b60d862ffffff6009866148879190615032565b63ffffffff164060001c16901b60c062ffffff6008876148a79190615032565b63ffffffff164060001c16901b60a862ffffff6007886148c79190615032565b63ffffffff164060001c16901b609062ffffff6006896148e79190615032565b63ffffffff164060001c16901b607862ffffff60058a6149079190615032565b63ffffffff164060001c16901b606062ffffff60048b6149279190615032565b63ffffffff164060001c16901b604862ffffff60038c6149479190615032565b63ffffffff164060001c16901b603062ffffff60028d6149679190615032565b63ffffffff164060001c16901b601862ffffff60018e6149879190615032565b63ffffffff164060001c16901b62ffffff8d63ffffffff164060001c1617171717171717171717905092915050565b60008082846149c59190614d95565b9050838110156149d8576149d76150a1565b5b8091505092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000614a12826149e7565b9050919050565b614a2281614a07565b8114614a2d57600080fd5b50565b600081359050614a3f81614a19565b92915050565b600060208284031215614a5b57614a5a6149e2565b5b6000614a6984828501614a30565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b83811015614aac578082015181840152602081019050614a91565b60008484015250505050565b6000601f19601f8301169050919050565b6000614ad482614a72565b614ade8185614a7d565b9350614aee818560208601614a8e565b614af781614ab8565b840191505092915050565b60006020820190508181036000830152614b1c8184614ac9565b905092915050565b6000819050919050565b614b3781614b24565b8114614b4257600080fd5b50565b600081359050614b5481614b2e565b92915050565b600060208284031215614b7057614b6f6149e2565b5b6000614b7e84828501614b45565b91505092915050565b60008060408385031215614b9e57614b9d6149e2565b5b6000614bac85828601614a30565b9250506020614bbd85828601614b45565b9150509250929050565b60008115159050919050565b614bdc81614bc7565b82525050565b6000602082019050614bf76000830184614bd3565b92915050565b614c0681614b24565b82525050565b6000602082019050614c216000830184614bfd565b92915050565b600080600060608486031215614c4057614c3f6149e2565b5b6000614c4e86828701614a30565b9350506020614c5f86828701614a30565b9250506040614c7086828701614b45565b9150509250925092565b60008060408385031215614c9157614c906149e2565b5b6000614c9f85828601614b45565b9250506020614cb085828601614a30565b9150509250929050565b614cc381614a07565b82525050565b6000602082019050614cde6000830184614cba565b92915050565b60008060408385031215614cfb57614cfa6149e2565b5b6000614d0985828601614a30565b9250506020614d1a85828601614a30565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000614d5e82614b24565b9150614d6983614b24565b9250828202614d7781614b24565b91508282048414831517614d8e57614d8d614d24565b5b5092915050565b6000614da082614b24565b9150614dab83614b24565b9250828201905080821115614dc357614dc2614d24565b5b92915050565b6000614dd482614b24565b9150614ddf83614b24565b9250828203905081811115614df757614df6614d24565b5b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000614e3782614b24565b9150614e4283614b24565b925082614e5257614e51614dfd565b5b828204905092915050565b600079ffffffffffffffffffffffffffffffffffffffffffffffffffff82169050919050565b6000614e8e82614e5d565b9150614e9983614e5d565b9250828201905079ffffffffffffffffffffffffffffffffffffffffffffffffffff811115614ecb57614eca614d24565b5b92915050565b60008160601b9050919050565b6000614ee982614ed1565b9050919050565b6000614efb82614ede565b9050919050565b614f13614f0e82614a07565b614ef0565b82525050565b6000819050919050565b614f34614f2f82614b24565b614f19565b82525050565b6000614f468285614f02565b601482019150614f568284614f23565b6020820191508190509392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000604082019050614faa6000830185614bfd565b614fb76020830184614bfd565b9392505050565b600063ffffffff82169050919050565b6000819050919050565b6000614ff3614fee614fe984614fbe565b614fce565b614b24565b9050919050565b61500381614fd8565b82525050565b600060408201905061501e6000830185614ffa565b61502b6020830184614bfd565b9392505050565b600061503d82614fbe565b915061504883614fbe565b9250828201905063ffffffff81111561506457615063614d24565b5b92915050565b600060608201905061507f6000830186614bfd565b61508c6020830185614bfd565b6150996040830184614bfd565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b60006150db82614b24565b91506150e683614b24565b9250826150f6576150f5614dfd565b5b828206905092915050565b600061510c82614b24565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff820361513e5761513d614d24565b5b600182019050919050565b600060ff82169050919050565b600061516182615149565b915061516c83615149565b9250828201905060ff81111561518557615184614d24565b5b9291505056fea2646970667358221220383439edce203253810737d9a2405a38d17d2b67d1e515f8fc8f707ed51c823364736f6c63430008180033","sourceMap":"4372:22747:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;21216:1;21204:9;:13;21201:304;;;21247:1;21235:11;;:13;21232:243;;;21330:13;21337:5;;;;;;;;;;;21330:6;:13::i;:::-;21232:243;;;21454:6;:4;:6::i;:::-;;21232:243;21488:7;;21201:304;21579:1;21564:11;;:16;:42;;;;;21605:1;21584:8;:20;21593:10;21584:20;;;;;;;;;;;;;;;;:22;21564:42;21561:88;;;21621:26;21636:10;21621:14;:26::i;:::-;21561:88;21658:5;:3;:5::i;:::-;21163:557;4372:22747;13443:1965;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;4464:51;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;10268:89;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;3557:306;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;18933:2063;;;;;;;;;;;;;:::i;:::-;;26179:671;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5555:22;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;599:23;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2923:404;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;22033:172;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;22313:1326;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;4565:33;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;658:23;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;6081:39;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;23779:545;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;8925:353;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;8228:113;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;9687:194;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;26950:166;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;18057:818;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;10459:107;;;;;;;;;;;;;:::i;:::-;;5935:20;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;7497:123;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5604:25;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;2397:113;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;7295:96;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5737:24;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;8000:131;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5451:23;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;626:20;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;8711:122;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;8469:114;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;21770:152;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;4521:38;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;12238:312;;;;;;;;;;;;;:::i;:::-;;5200:27;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;9403:185;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;1691:500;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;24402:87;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5677:24;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;11401:68;;;:::i;:::-;;5867:32;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;13263:71;;;:::i;:::-;;5347:43;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5108:29;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;10851:485;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;6148:29;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;11551:613;;;;;;;;;;;;;:::i;:::-;;4185:142;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;5802:26;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;16079:132;;;;;;;;;;;;;:::i;:::-;;5286:29;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;15534:490;;;;;;;;;;;;;:::i;:::-;;5415:30;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;7739:133;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;9985:167;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;:::i;:::-;;13443:1965;13598:1;13584:11;;:15;:64;;;;;13646:1;6115:5;13633:14;;;;:::i;:::-;13618:11;;:30;;;;:::i;:::-;13603:12;:45;13584:64;:100;;;;;13668:16;;13652:13;;:32;13584:100;13576:109;;;;;;13695:14;13712:9;13695:26;;13765:13;;13746:16;;:32;;;;:::i;:::-;13734:9;:44;13731:382;;;13825:13;;13806:16;;:32;;;;:::i;:::-;13794:44;;13868:16;;13852:13;:32;;;;13912:1;13898:11;:15;;;;13961:10;13953:28;;:54;13982:24;13996:9;13982;:13;;:24;;;;:::i;:::-;13953:54;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13731:382;;;14093:9;14076:13;;:26;;;;;;;:::i;:::-;;;;;;;;13731:382;14145:1;14125:22;;:8;:22;;;:43;;;;14163:5;;;;;;;;;;;14151:17;;:8;:17;;;14125:43;14122:435;;;14212:2;14200:9;:14;;;;:::i;:::-;14183:13;;:31;;;;;;;:::i;:::-;;;;;;;;14274:2;14262:9;:14;;;;:::i;:::-;14228:7;:14;14236:5;;;;;;;;;;;14228:14;;;;;;;;;;;;;;;:22;;;:49;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;14122:435;;;14385:1;14378:3;14374:1;14362:9;:13;;;;:::i;:::-;:19;;;;:::i;:::-;14361:25;;;;:::i;:::-;14344:13;;:42;;;;;;;:::i;:::-;;;;;;;;14450:3;14446:1;14434:9;:13;;;;:::i;:::-;:19;;;;:::i;:::-;14400:7;:14;14408:5;;;;;;;;;;;14400:14;;;;;;;;;;;;;;;:22;;;:54;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;14551:3;14547:1;14535:9;:13;;;;:::i;:::-;:19;;;;:::i;:::-;14498:7;:17;14506:8;14498:17;;;;;;;;;;;;;;;:25;;;:57;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;14122:435;14635:14;;14587:7;:19;14595:10;14587:19;;;;;;;;;;;;;;;:38;;;:63;;;;;;;;;;;;;;;;;;14692:18;14725:6;14713:9;:18;;;;:::i;:::-;14692:39;;14741:17;14778:6;14773:2;14761:9;:14;;;;:::i;:::-;:23;;;;:::i;:::-;14741:43;;14796:20;14836:6;14831:2;14819:9;:14;;;;:::i;:::-;:23;;;;:::i;:::-;14796:46;;14878:13;14854:8;:20;14863:10;14854:20;;;;;;;;;;;;;;;;:37;;;;;;;:::i;:::-;;;;;;;;14920:12;14901:8;:15;14910:5;;;;;;;;;;;14901:15;;;;;;;;;;;;;;;;:31;;;;;;;:::i;:::-;;;;;;;;14999:15;14977:8;:18;14986:8;;;;;;;;;;;14977:18;;;;;;;;;;;;;;;;:37;;;;;;;:::i;:::-;;;;;;;;15102:15;15087:12;15071:13;:28;;;;:::i;:::-;:46;;;;:::i;:::-;15056:11;;:61;;;;;;;:::i;:::-;;;;;;;;15152:10;15132:45;;15149:1;15132:45;;;15163:13;15132:45;;;;;;:::i;:::-;;;;;;;;15229:5;;;;;;;;;;;15209:39;;15226:1;15209:39;;;15235:12;15209:39;;;;;;:::i;:::-;;;;;;;;15300:8;;;;;;;;;;;15280:45;;15297:1;15280:45;;;15309:15;15280:45;;;;;;:::i;:::-;;;;;;;;15382:8;15357:44;;15371:10;15357:44;;;15391:9;15357:44;;;;;;:::i;:::-;;;;;;;;13492:1916;;;;13443:1965;:::o;21770:152::-;21810:4;21833:82;21876:10;21887:12;21859:41;;;;;;;;;:::i;:::-;;;;;;;;;;;;;21849:52;;;;;;21844:58;;21912:1;21833:10;:82::i;:::-;21826:89;;21770:152;:::o;16298:747::-;16364:9;16376:7;:13;16384:4;16376:13;;;;;;;;;;;;;;;:32;;;;;;;;;;;;16364:44;;;;16438:1;16422:8;:14;16431:4;16422:14;;;;;;;;;;;;;;;;:17;16421:32;;;;16451:1;16445:4;:7;16421:32;16418:136;;;16508:14;;16468:7;:13;16476:4;16468:13;;;;;;;;;;;;;;;:32;;;:55;;;;;;;;;;;;;;;;;;16537:7;;;16418:136;16572:14;;16566:4;:20;16563:56;;16602:7;;;16563:56;16628:10;16671:11;;16658:10;16641:8;:14;16650:4;16641:14;;;;;;;;;;;;;;;;:27;;;;:::i;:::-;:41;;;;:::i;:::-;16628:54;;16692:12;16718:92;16728:14;;16723:4;:19;16718:92;;;16784:9;16794:4;16784:15;;;;;;;;:::i;:::-;;;;;;;;;;16776:5;:23;;;;:::i;:::-;16765:34;;;;;:::i;:::-;;;16743:6;;;;;;;16718:92;;;16840:10;16830:7;:20;;;;:::i;:::-;16819:32;;16878:7;16861:13;;:24;;;;;;;:::i;:::-;;;;;;;;16928:7;16895;:13;16903:4;16895:13;;;;;;;;;;;;;;;:21;;;:41;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;16988:4;16946:7;:13;16954:4;16946:13;;;;;;;;;;;;;;;:32;;;:47;;;;;;;;;;;;;;;;;;17020:4;17008:30;;;17025:7;17033:4;17008:30;;;;;;;:::i;:::-;;;;;;;;16354:691;;;16298:747;;:::o;18933:2063::-;18965:17;18985:4;:16;18990:10;18985:16;;;;;;;;;;;;;;;18965:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;19031:1;19014:6;:15;;;:18;;;19011:149;;19089:40;;;;;;;;19101:1;19089:40;;;;;;19113:1;19089:40;;;;;;19126:1;19089:40;;;;;19070:4;:16;19075:10;19070:16;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;19143:7;;;19011:149;19187:1;19173:6;:12;;;:15;;;19172:41;;;;19211:1;19194:6;:15;;;:18;;;19172:41;19169:101;;;19228:11;:9;:11::i;:::-;19253:7;;;19169:101;19300:6;:15;;;19287:28;;:12;:28;19279:37;;;;;;19406:12;6115:5;19386:2;:15;;;;:::i;:::-;19367:6;:15;;;:35;;;;;;:::i;:::-;:51;19364:259;;19479:10;19471:48;;;19490:6;:15;;;19506:12;19471:48;;;;;;;:::i;:::-;;;;;;;;19552:40;;;;;;;;19564:1;19552:40;;;;;;19576:1;19552:40;;;;;;19589:1;19552:40;;;;;19533:4;:16;19538:10;19533:16;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;19606:7;;;19364:259;19632:10;19656:11;19713:3;19697:6;:15;;;:19;;;;:::i;:::-;19684:32;;:12;:32;19681:884;;;19805:6;:15;;;19795:26;;;19790:32;;19776:47;;;;19845:29;19854:6;19868:4;19845:8;:29::i;:::-;19837:37;;19681:884;;;19926:1;19916:9;;:11;19913:642;;;20074:24;20082:6;:15;;;20074:24;;:7;:24::i;:::-;20067:31;;20127:9;20119:4;:17;;;20116:226;;20211:6;:12;;;20206:18;;20198:26;;20116:226;;;20294:29;20303:6;20317:4;20294:8;:29::i;:::-;20286:37;;20116:226;19913:642;;;20397:10;20389:48;;;20408:6;:15;;;20424:12;20389:48;;;;;;;:::i;:::-;;;;;;;;20474:40;;;;;;;;20486:1;20474:40;;;;;;20498:1;20474:40;;;;;;20511:1;20474:40;;;;;20455:4;:16;20460:10;20455:16;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20532:8;;;;;19913:642;19681:884;20593:40;;;;;;;;20605:1;20593:40;;;;;;20617:1;20593:40;;;;;;20630:1;20593:40;;;;;20574:4;:16;20579:10;20574:16;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20652:1;20646:5;:7;20643:347;;;20681:10;20674:56;;;20697:6;:14;;;20692:20;;20718:4;20713:10;;20724:5;20674:56;;;;;;;;:::i;:::-;;;;;;;;20755:6;;20747:5;:14;20744:118;;;20789:5;20780:6;:14;;;;20830:10;20817:30;;;20841:5;20817:30;;;;;;:::i;:::-;;;;;;;;20744:118;20875:10;20879:5;20875:3;:10::i;:::-;20643:347;;;20936:10;20928:51;;;20952:6;:14;;;20947:20;;20973:4;20968:10;;20928:51;;;;;;;:::i;:::-;;;;;;;;20643:347;18955:2041;;;18933:2063;:::o;4464:51::-;;;;;;;;;;;;;;;;;;;:::o;10268:89::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;:::i;:::-;;10343:7:::1;10330:10;:20;;;;10268:89:::0;:::o;3557:306::-;3721:1;3711:6;:11;;3710:53;;;;;3761:1;3728:7;:19;3736:10;3728:19;;;;;;;;;;;;;;;:29;3748:8;3728:29;;;;;;;;;;;;;;;;:34;;3710:53;3708:56;3701:64;;;;:::i;:::-;;3803:6;3771:7;:19;3779:10;3771:19;;;;;;;;;;;;;;;:29;3791:8;3771:29;;;;;;;;;;;;;;;:38;;;;3841:8;3820:38;;3829:10;3820:38;;;3851:6;3820:38;;;;;;:::i;:::-;;;;;;;;3557:306;;:::o;26179:671::-;26214:4;26230:10;26243:8;;26230:21;;26273:1;26264:5;:10;:40;;;;26302:2;26294:5;:10;;;;:::i;:::-;26278:12;:26;;26264:40;26261:83;;;26327:5;26320:13;;;;;26261:83;26353:14;26393:3;26380:12;:16;26377:159;;;26456:1;26444:13;;26377:159;;;26522:3;26507:12;:18;;;;:::i;:::-;26495:30;;26377:159;26556:9;26548:5;:17;26545:121;;;26581:8;26592:9;26581:20;;26628:2;26622:3;:8;;;;:::i;:::-;26615:15;;;;;:::i;:::-;;;26652:3;26644:11;;26567:99;26545:121;26675:10;26710:2;26697:9;;26689:5;:17;;;;:::i;:::-;26688:24;;;;:::i;:::-;26675:37;;26751:39;26769:5;26783;26751:10;:39::i;:::-;26722:6;6115:5;26729;:18;;;;:::i;:::-;26722:26;;;;;;;;:::i;:::-;;;;;;;;;:68;;;;26819:2;26811:5;:10;;;;:::i;:::-;26800:8;:21;;;;26838:4;26831:12;;;;;26179:671;;:::o;5555:22::-;;;;:::o;599:23::-;;;;:::o;2923:404::-;3018:6;1523:1;1516:4;:8;;;;:::i;:::-;1497;;:15;;:27;;1490:35;;;;:::i;:::-;;3032:15:::1;3050:7;:14;3058:5;3050:14;;;;;;;;;;;;;;;:26;3065:10;3050:26;;;;;;;;;;;;;;;;3032:44;;3082:21;3097:5;3082:14;:21::i;:::-;3109:19;3124:3;3109:14;:19::i;:::-;3150:25;3168:6;3150:8;:13;3159:3;3150:13;;;;;;;;;;;;;;;;:17;;:25;;;;:::i;:::-;3134:8;:13;3143:3;3134:13;;;;;;;;;;;;;;;:41;;;;3199:27;3219:6;3199:8;:15;3208:5;3199:15;;;;;;;;;;;;;;;;:19;;:27;;;;:::i;:::-;3181:8;:15;3190:5;3181:15;;;;;;;;;;;;;;;:45;;;;3261:22;3276:6;3261:10;:14;;:22;;;;:::i;:::-;3232:7;:14;3240:5;3232:14;;;;;;;;;;;;;;;:26;3247:10;3232:26;;;;;;;;;;;;;;;:51;;;;3310:3;3294:28;;3303:5;3294:28;;;3315:6;3294:28;;;;;;:::i;:::-;;;;;;;;3026:301;2923:404:::0;;;;:::o;22033:172::-;22095:4;22118:80;22161:10;22172:12;22144:41;;;;;;;;;:::i;:::-;;;;;;;;;;;;;22134:52;;;;;;22129:58;;22189:8;22118:10;:80::i;:::-;22111:87;;22033:172;;;:::o;22313:1326::-;22387:4;22403:5;:3;:5::i;:::-;22449:14;22473:5;22449:30;;22510:7;22497:9;:20;;:46;;;;;22533:10;;22521:9;:22;22497:46;22489:55;;;;;;22569:1;22557:9;:13;22554:1003;;;22601:1;22588:11;;:14;22585:154;;22707:2;22695:9;:14;;;;:::i;:::-;22666:9;22676:14;;22666:25;;;;;;;;:::i;:::-;;;;;;;;;;:43;;;;;;;:::i;:::-;;;;;;;;22585:154;22775:1;22755:22;;:8;:22;;;22752:204;;22797:8;22820:3;22808:9;:15;;;;:::i;:::-;22797:26;;22858:3;22841:13;;:20;;;;;;;:::i;:::-;;;;;;;;22916:3;22879:7;:17;22887:8;22879:17;;;;;;;;;;;;;;;:25;;;:41;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;22779:177;22752:204;22998:1;22983:12;:16;;;;:::i;:::-;22972:8;;:27;22969:389;;;23045:1;23030:12;:16;;;;:::i;:::-;23019:8;:27;;;;23077:9;23064:10;:22;;;;22969:389;;;23152:10;;23139;;:23;23136:208;;;23186:8;;:10;;;;;;;;;:::i;:::-;;;;;;23231:9;23218:10;:22;;;;23136:208;;;23316:9;23302:10;;:23;;;;;;;:::i;:::-;;;;;;;;23136:208;22969:389;23390:86;;;;;;;;23410:9;23390:86;;;;;;23438:7;23431:15;;23390:86;;;;;;23465:8;;23390:86;;;;;23371:4;:16;23376:10;23371:16;;;;;;;;;;;;;;;:105;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23502:10;23495:51;;;23518:7;23513:13;;23527:8;;23536:9;23495:51;;;;;;;;:::i;:::-;;;;;;;;22554:1003;23566:9;:7;:9::i;:::-;;23623:8;;23616:16;;;22313:1326;;;;:::o;4565:33::-;4597:1;4565:33;:::o;658:23::-;;;;;;;;;;;;;:::o;6081:39::-;6115:5;6081:39;:::o;23779:545::-;23826:4;23863:1;23850:9;;:14;:27;;;;;23876:1;23868:5;:9;23850:27;:50;;;;;6115:5;23881;:19;;23850:50;23842:59;;;;;;23911:6;23936:5;23920:6;:13;;;;:21;;;;:::i;:::-;23911:30;;6115:5;23954:1;:14;23951:57;;;6115:5;23983:14;;23951:57;24021:6;24028;:13;;;;24021:20;;24017:97;24044:1;24042;:3;24017:97;;;24089:6;24101:1;24089:14;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;24046:3;;;;;;;24017:97;;;;6115:5;24126:6;:13;;;;:25;24123:164;;24239:2;24224:12;:17;;;;:::i;:::-;24207:12;:35;;;;:::i;:::-;24195:9;:47;;;;24267:9;;24256:8;:20;;;;24123:164;24303:6;:13;;;;24296:21;;;23779:545;;;:::o;8925:353::-;8975:4;9008:1;8994:11;;:15;8991:54;;;9032:1;9025:9;;;;8991:54;9054:11;6115:5;9098:2;:15;;;;:::i;:::-;9084:9;;9069:12;:24;;;;:::i;:::-;9068:46;;;;:::i;:::-;9054:60;;9136:14;;9127:6;:23;9124:62;;;9173:1;9166:9;;;;;9124:62;6115:5;9253:2;:15;;;;:::i;:::-;9239:9;;9224:12;:24;;;;:::i;:::-;9223:46;;;;:::i;:::-;6115:5;9203:2;:15;;;;:::i;:::-;9202:68;;;;:::i;:::-;9195:76;;;8925:353;;:::o;8228:113::-;8287:4;8315;:12;8320:6;8315:12;;;;;;;;;;;;;;;:18;;;;;;;;;;;;8310:24;;8303:31;;8228:113;;;:::o;9687:194::-;6924:8;;;;;;;;;;;6910:22;;:10;:22;;;6903:30;;;;:::i;:::-;;9780:1:::1;9764:18;;:4;:18;;::::0;9757:26:::1;;;;:::i;:::-;;9793;9808:10;9793:14;:26::i;:::-;9829:20;9844:4;9829:14;:20::i;:::-;9870:4;9859:8;;:15;;;;;;;;;;;;;;;;;;9687:194:::0;:::o;26950:166::-;26999:6;27017:93;27024:4;27022:1;:6;27017:93;;;27051:9;:7;:9::i;:::-;27047:53;;27079:7;;;27047:53;27029:3;;;;;;;27017:93;;;26989:127;26950:166;;:::o;18057:818::-;18109:4;18126:17;18146:4;:10;18151:4;18146:10;;;;;;;;;;;;;;;18126:30;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;18185:1;18171:6;:12;;;:15;;;18170:53;;;;18221:1;18204:6;:15;;;:18;;;;18170:53;:99;;;;18253:6;:15;;;18240:28;;:12;:28;18170:99;:166;;;;6115:5;18319:2;:15;;;;:::i;:::-;18300:6;:15;;;:35;;;;;;:::i;:::-;18286:12;:49;;18170:166;18166:205;;;18358:1;18351:9;;;;;18166:205;18412:3;18396:6;:15;;;:19;;;;:::i;:::-;18383:32;;:12;:32;18380:171;;;18482:57;18491:6;18520;:15;;;18510:26;;;18505:32;;18482:8;:57::i;:::-;18475:65;;;;;18380:171;18573:1;18563:9;;:11;18560:290;;;18589:11;18603:24;18611:6;:15;;;18603:24;;:7;:24::i;:::-;18589:38;;18652:9;18644:4;:17;;;18641:206;;18731:6;:12;;;18726:18;;18719:26;;;;;;18641:206;18802:29;18811:6;18825:4;18802:8;:29::i;:::-;18795:37;;;;;;18560:290;18866:1;18859:9;;;18057:818;;;;:::o;10459:107::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;:::i;:::-;;10534:1:::1;10519:12;:16;;;;:::i;:::-;10508:8;:27;;;;10558:1;10545:10;:14;;;;10459:107::o:0;5935:20::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;7497:123::-;7561:4;7589:7;:15;7597:6;7589:15;;;;;;;;;;;;;;;:23;;;;;;;;;;;;7584:29;;7577:36;;7497:123;;;:::o;5604:25::-;;;;:::o;2397:113::-;2462:12;2489:8;:16;2498:6;2489:16;;;;;;;;;;;;;;;;2482:23;;2397:113;;;:::o;7295:96::-;7342:4;7370:6;:13;;;;7358:26;;7295:96;:::o;5737:24::-;;;;:::o;8000:131::-;8062:4;8090:7;:15;8098:6;8090:15;;;;;;;;;;;;;;;:33;;;;;;;;;;;;8085:39;;8078:46;;8000:131;;;:::o;5451:23::-;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;626:20::-;;;;;;;;;;;;;:::o;8711:122::-;8776:4;8804;:12;8809:6;8804:12;;;;;;;;;;;;;;;:21;;;;;;;;;;;;8799:27;;8792:34;;8711:122;;;:::o;8469:114::-;8527:4;8555;:12;8560:6;8555:12;;;;;;;;;;;;;;;:20;;;;;;;;;;;;8550:26;;8543:33;;8469:114;;;:::o;4521:38::-;;;;;;;;;;;;;;;;;;;:::o;12238:312::-;12309:1;12279:7;:19;12287:10;12279:19;;;;;;;;;;;;;;;:27;;;;;;;;;;;;:31;;;:88;;;;;12355:12;12314:7;:19;12322:10;12314:19;;;;;;;;;;;;;;;:37;;;;;;;;;;;;:53;;;;12279:88;12276:268;;;12382:12;12397:7;:19;12405:10;12397:19;;;;;;;;;;;;;;;:27;;;;;;;;;;;;12382:42;;;;12468:1;12438:7;:19;12446:10;12438:19;;;;;;;;;;;;;;;:27;;;:31;;;;;;;;;;;;;;;;;;12500:7;12483:13;;:24;;;;;;;:::i;:::-;;;;;;;;12521:12;12525:7;12521:3;:12::i;:::-;12368:176;12276:268;12238:312::o;5200:27::-;;;;:::o;9403:185::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;:::i;:::-;;9490:1:::1;9474:18;;:4;:18;;::::0;9467:26:::1;;;;:::i;:::-;;9503;9518:10;9503:14;:26::i;:::-;9539:20;9554:4;9539:14;:20::i;:::-;9577:4;9569:5;;:12;;;;;;;;;;;;;;;;;;9403:185:::0;:::o;1691:500::-;1767:6;1523:1;1516:4;:8;;;;:::i;:::-;1497;;:15;;:27;;1490:35;;;;:::i;:::-;;1781:26:::1;1796:10;1781:14;:26::i;:::-;1836:32;1861:6;1836:8;:20;1845:10;1836:20;;;;;;;;;;;;;;;;:24;;:32;;;;:::i;:::-;1813:8;:20;1822:10;1813:20;;;;;;;;;;;;;;;:55;;;;1892:4;1877:20;;:3;:20;;::::0;1874:313:::1;;1909:21;1924:5;;;;;;;;;;;1909:14;:21::i;:::-;1958:27;1978:6;1958:8;:15;1967:5;;;;;;;;;;;1958:15;;;;;;;;;;;;;;;;:19;;:27;;;;:::i;:::-;1940:8;:15;1949:5;;;;;;;;;;;1940:15;;;;;;;;;;;;;;;:45;;;;2021:5;;;;;;;;;;;2000:35;;2009:10;2000:35;;;2028:6;2000:35;;;;;;:::i;:::-;;;;;;;;1874:313;;;2062:19;2077:3;2062:14;:19::i;:::-;2107:25;2125:6;2107:8;:13;2116:3;2107:13;;;;;;;;;;;;;;;;:17;;:25;;;;:::i;:::-;2091:8;:13;2100:3;2091:13;;;;;;;;;;;;;;;:41;;;;2168:3;2147:33;;2156:10;2147:33;;;2173:6;2147:33;;;;;;:::i;:::-;;;;;;;;1874:313;1691:500:::0;;;:::o;24402:87::-;24444:4;24467:14;24477:3;24467:9;:14::i;:::-;24460:22;;24402:87;:::o;5677:24::-;;;;:::o;11401:68::-;11448:14;:12;:14::i;:::-;11401:68::o;5867:32::-;;;;:::o;13263:71::-;13314:13;13321:5;;;;;;;;;;;13314:6;:13::i;:::-;13263:71::o;5347:43::-;;;;:::o;5108:29::-;;;;:::o;10851:485::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;:::i;:::-;;10913:14:::1;:12;:14::i;:::-;10955:1;10945:7;:11;:90;;;;;11028:7;11012:13;;11006:2;11002:1;10986:13:::0;::::1;:17;;;;:::i;:::-;:22;;;;:::i;:::-;10985:40;;;;:::i;:::-;:50;;;;:::i;:::-;10960:21;:75;;10945:90;10937:99;;;::::0;::::1;;11085:1;11066:16;;:20;;;;:::i;:::-;11049:13;;:37;11046:199;;11178:3;11154:21;:27;;;;:::i;:::-;11143:7;:38;;11142:91;;;;;11221:12;11202:15;11186:13;;:31;;;;:::i;:::-;:47;;11142:91;11134:100;;;::::0;::::1;;11046:199;11262:10;11254:28;;:37;11283:7;11254:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;11317:12;11301:13;:28;;;;10851:485:::0;:::o;6148:29::-;;;;:::o;11551:613::-;11609:1;11595:11;;:15;:65;;;;;11658:1;6115:5;11645:14;;;;:::i;:::-;11630:11;;:30;;;;:::i;:::-;11614:12;:46;;11595:65;11592:566;;;11704:1;11690:11;:15;;;;11592:566;;;11786:1;11774:9;;:13;11771:377;;;11800:11;6115:5;11844:2;:15;;;;:::i;:::-;11830:9;;11815:12;:24;;;;:::i;:::-;11814:47;;;;:::i;:::-;11800:61;;11910:1;11891:9;:16;;;;:20;;;;:::i;:::-;11882:6;:29;11879:92;;;11935:9;11950:1;11935:17;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;11879:92;12000:14;;11991:6;:23;:43;;;;;12033:1;12018:11;;:16;11991:43;:84;;;;;12074:1;12055:9;:16;;;;:20;;;;:::i;:::-;12038:14;;:37;11991:84;11988:146;;;12099:14;;:16;;;;;;;;;:::i;:::-;;;;;;11988:146;11788:360;11771:377;11592:566;11551:613::o;4185:142::-;4268:14;4297:7;:15;4305:6;4297:15;;;;;;;;;;;;;;;:25;4313:8;4297:25;;;;;;;;;;;;;;;;4290:32;;4185:142;;;;:::o;5802:26::-;;;;:::o;16079:132::-;16145:1;16130:11;;:16;16122:25;;;;;;16157:26;16172:10;16157:14;:26::i;:::-;16193:11;:9;:11::i;:::-;16079:132::o;5286:29::-;;;;:::o;15534:490::-;15597:1;15582:11;;:16;15574:25;;;;;;15609:26;15624:10;15609:14;:26::i;:::-;15645:22;15693:6;15670:8;:20;15679:10;15670:20;;;;;;;;;;;;;;;;:29;;;;:::i;:::-;15645:54;;15742:1;15714:52;;15723:10;15714:52;;;15745:8;:20;15754:10;15745:20;;;;;;;;;;;;;;;;15714:52;;;;;;:::i;:::-;;;;;;;;15800:8;:20;15809:10;15800:20;;;;;;;;;;;;;;;15793:27;;;15903:17;15886:13;;:34;;;;;;;:::i;:::-;;;;;;;;15993:2;15989:1;15969:17;:21;;;;:::i;:::-;:26;;;;:::i;:::-;15930:7;:19;15938:10;15930:19;;;;;;;;;;;;;;;:27;;;:66;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;16006:11;:9;:11::i;:::-;15564:460;15534:490::o;5415:30::-;;;;:::o;7739:133::-;7802:4;7830:7;:15;7838:6;7830:15;;;;;;;;;;;;;;;:34;;;;;;;;;;;;7825:40;;7818:47;;7739:133;;;:::o;9985:167::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;:::i;:::-;;10073:1:::1;10058:11;;:16;:33;;;;;10090:1;10078:9;;:13;10058:33;:57;;;;;10110:5;10095:12;:20;10058:57;10050:66;;;::::0;::::1;;10140:5;10126:11;:19;;;;9985:167:::0;:::o;341:101::-;393:4;417:1;412;:6;;405:14;;;;:::i;:::-;;436:1;432;:5;;;;:::i;:::-;425:12;;341:101;;;;:::o;17076:923::-;17150:4;17186:14;17210:7;:15;;;17186:40;;17236:10;17259:5;17249:7;:15;17236:28;;17274:14;17544:1;17531:8;17525:3;:14;17524:21;;;:29;;17552:1;17524:29;;;17548:1;17524:29;17497:1;17485:7;17479:3;:13;17478:20;;;:28;;17505:1;17478:28;;;17501:1;17478:28;17451:1;17440:6;17434:3;:12;17433:19;;;:27;;17459:1;17433:27;;;17455:1;17433:27;17406:1;17396:5;17390:3;:11;17389:18;;;:26;;17414:1;17389:26;;;17410:1;17389:26;17362:1;17353:4;17347:3;:10;17346:17;;;:25;;17370:1;17346:25;;;17366:1;17346:25;17319:1;17311:3;17305;:9;17304:16;;;:24;;17327:1;17304:24;;;17323:1;17304:24;17303:70;;;;:::i;:::-;:114;;;;:::i;:::-;:159;;;;:::i;:::-;:205;;;;:::i;:::-;:252;;;;:::i;:::-;17274:281;;;;17579:1;17568:7;:12;;;17565:78;;17624:7;17607;:13;;;17602:19;;:29;;;;:::i;:::-;17595:37;;;;;;;17565:78;17666:1;17655:7;:12;;;17652:76;;17711:5;17694:7;:13;;;17689:19;;:27;;;;:::i;:::-;17682:35;;;;;;;17652:76;17751:1;17740:7;:12;;;17737:74;;17796:3;17779:7;:13;;;17774:19;;:25;;;;:::i;:::-;17767:33;;;;;;;17737:74;17834:1;17823:7;:12;;;17820:73;;17879:2;17862:7;:13;;;17857:19;;:24;;;;:::i;:::-;17850:32;;;;;;;17820:73;17916:1;17905:7;:12;;;17902:72;;17961:1;17944:7;:13;;;17939:19;;:23;;;;:::i;:::-;17932:31;;;;;;;17902:72;17990:1;17983:9;;;;;17076:923;;;;;:::o;25730:400::-;25782:6;25800:10;25836:2;25823:9;;25814:6;:18;;;;:::i;:::-;25813:25;;;;:::i;:::-;25800:38;;25848:9;25860:6;6115:5;25867;:18;;;;:::i;:::-;25860:26;;;;;;;;:::i;:::-;;;;;;;;;;25848:38;;25929:3;25921:4;:11;;6115:5;25899;:18;;;;:::i;:::-;:33;25896:121;;25955:9;25948:17;;;;;;25896:121;26026:10;26062:2;26049:9;;26040:6;:18;;;;:::i;:::-;26039:25;;;;:::i;:::-;26026:38;;26113:8;26103:5;26098:2;:10;;;;:::i;:::-;26089:4;:20;;26088:33;26074:49;;;;;25730:400;;;;:::o;12556:634::-;12601:11;12639:1;12615:21;:25;;;;:::i;:::-;12601:39;;12663:7;12653:6;:17;12650:534;;12694:10;12686:28;;:37;12715:7;12686:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12750:8;12740:7;:18;12737:82;;;12790:14;:12;:14::i;:::-;12737:82;12650:534;;;12857:16;12886:6;12876:7;:16;;;;:::i;:::-;12857:35;;12923:11;12906:13;;:28;;;;;;;:::i;:::-;;;;;;;;12987:11;12948:7;:19;12956:10;12948:19;;;;;;;;;;;;;;;:27;;;:51;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;13075:16;13060:12;:31;;;;:::i;:::-;13013:7;:19;13021:10;13013:19;;;;;;;;;;;;;;;:37;;;:79;;;;;;;;;;;;;;;;;;13145:10;13137:28;;:36;13166:6;13137:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12843:341;12650:534;12591:599;12556:634;:::o;24495:1229::-;24567:4;25712:3;6115:5;25687:6;25682:12;;:25;;;;:::i;:::-;25680:35;;25658:3;25644:8;25638:1;25631:6;:8;;;;:::i;:::-;25621:19;;;25616:25;;:36;25614:47;;25547:3;25533:8;25527:1;25520:6;:8;;;;:::i;:::-;25510:19;;;25505:25;;:36;25503:47;;25436:3;25422:8;25416:1;25409:6;:8;;;;:::i;:::-;25399:19;;;25394:25;;:36;25392:47;;25325:3;25311:8;25305:1;25298:6;:8;;;;:::i;:::-;25288:19;;;25283:25;;:36;25281:47;;25214:3;25200:8;25194:1;25187:6;:8;;;;:::i;:::-;25177:19;;;25172:25;;:36;25170:47;;25104:2;25090:8;25084:1;25077:6;:8;;;;:::i;:::-;25067:19;;;25062:25;;:36;25060:46;;24994:2;24980:8;24974:1;24967:6;:8;;;;:::i;:::-;24957:19;;;24952:25;;:36;24950:46;;24884:2;24870:8;24864:1;24857:6;:8;;;;:::i;:::-;24847:19;;;24842:25;;:36;24840:46;;24774:2;24760:8;24754:1;24747:6;:8;;;;:::i;:::-;24737:19;;;24732:25;;:36;24730:46;;24662:8;24649:6;24639:19;;;24634:25;;:36;24632:146;:256;:366;:476;:587;:698;:809;:920;:1031;:1084;24624:1093;;24495:1229;;;;:::o;445:117::-;497:4;509:6;522:1;518;:5;;;;:::i;:::-;509:14;;541:1;536;:6;;529:14;;;;:::i;:::-;;556:1;549:8;;;445:117;;;;:::o;88::1:-;197:1;194;187:12;334:126;371:7;411:42;404:5;400:54;389:65;;334:126;;;:::o;466:96::-;503:7;532:24;550:5;532:24;:::i;:::-;521:35;;466:96;;;:::o;568:122::-;641:24;659:5;641:24;:::i;:::-;634:5;631:35;621:63;;680:1;677;670:12;621:63;568:122;:::o;696:139::-;742:5;780:6;767:20;758:29;;796:33;823:5;796:33;:::i;:::-;696:139;;;;:::o;841:329::-;900:6;949:2;937:9;928:7;924:23;920:32;917:119;;;955:79;;:::i;:::-;917:119;1075:1;1100:53;1145:7;1136:6;1125:9;1121:22;1100:53;:::i;:::-;1090:63;;1046:117;841:329;;;;:::o;1176:99::-;1228:6;1262:5;1256:12;1246:22;;1176:99;;;:::o;1281:169::-;1365:11;1399:6;1394:3;1387:19;1439:4;1434:3;1430:14;1415:29;;1281:169;;;;:::o;1456:246::-;1537:1;1547:113;1561:6;1558:1;1555:13;1547:113;;;1646:1;1641:3;1637:11;1631:18;1627:1;1622:3;1618:11;1611:39;1583:2;1580:1;1576:10;1571:15;;1547:113;;;1694:1;1685:6;1680:3;1676:16;1669:27;1518:184;1456:246;;;:::o;1708:102::-;1749:6;1800:2;1796:7;1791:2;1784:5;1780:14;1776:28;1766:38;;1708:102;;;:::o;1816:377::-;1904:3;1932:39;1965:5;1932:39;:::i;:::-;1987:71;2051:6;2046:3;1987:71;:::i;:::-;1980:78;;2067:65;2125:6;2120:3;2113:4;2106:5;2102:16;2067:65;:::i;:::-;2157:29;2179:6;2157:29;:::i;:::-;2152:3;2148:39;2141:46;;1908:285;1816:377;;;;:::o;2199:313::-;2312:4;2350:2;2339:9;2335:18;2327:26;;2399:9;2393:4;2389:20;2385:1;2374:9;2370:17;2363:47;2427:78;2500:4;2491:6;2427:78;:::i;:::-;2419:86;;2199:313;;;;:::o;2518:77::-;2555:7;2584:5;2573:16;;2518:77;;;:::o;2601:122::-;2674:24;2692:5;2674:24;:::i;:::-;2667:5;2664:35;2654:63;;2713:1;2710;2703:12;2654:63;2601:122;:::o;2729:139::-;2775:5;2813:6;2800:20;2791:29;;2829:33;2856:5;2829:33;:::i;:::-;2729:139;;;;:::o;2874:329::-;2933:6;2982:2;2970:9;2961:7;2957:23;2953:32;2950:119;;;2988:79;;:::i;:::-;2950:119;3108:1;3133:53;3178:7;3169:6;3158:9;3154:22;3133:53;:::i;:::-;3123:63;;3079:117;2874:329;;;;:::o;3209:474::-;3277:6;3285;3334:2;3322:9;3313:7;3309:23;3305:32;3302:119;;;3340:79;;:::i;:::-;3302:119;3460:1;3485:53;3530:7;3521:6;3510:9;3506:22;3485:53;:::i;:::-;3475:63;;3431:117;3587:2;3613:53;3658:7;3649:6;3638:9;3634:22;3613:53;:::i;:::-;3603:63;;3558:118;3209:474;;;;;:::o;3689:90::-;3723:7;3766:5;3759:13;3752:21;3741:32;;3689:90;;;:::o;3785:109::-;3866:21;3881:5;3866:21;:::i;:::-;3861:3;3854:34;3785:109;;:::o;3900:210::-;3987:4;4025:2;4014:9;4010:18;4002:26;;4038:65;4100:1;4089:9;4085:17;4076:6;4038:65;:::i;:::-;3900:210;;;;:::o;4116:118::-;4203:24;4221:5;4203:24;:::i;:::-;4198:3;4191:37;4116:118;;:::o;4240:222::-;4333:4;4371:2;4360:9;4356:18;4348:26;;4384:71;4452:1;4441:9;4437:17;4428:6;4384:71;:::i;:::-;4240:222;;;;:::o;4468:619::-;4545:6;4553;4561;4610:2;4598:9;4589:7;4585:23;4581:32;4578:119;;;4616:79;;:::i;:::-;4578:119;4736:1;4761:53;4806:7;4797:6;4786:9;4782:22;4761:53;:::i;:::-;4751:63;;4707:117;4863:2;4889:53;4934:7;4925:6;4914:9;4910:22;4889:53;:::i;:::-;4879:63;;4834:118;4991:2;5017:53;5062:7;5053:6;5042:9;5038:22;5017:53;:::i;:::-;5007:63;;4962:118;4468:619;;;;;:::o;5093:474::-;5161:6;5169;5218:2;5206:9;5197:7;5193:23;5189:32;5186:119;;;5224:79;;:::i;:::-;5186:119;5344:1;5369:53;5414:7;5405:6;5394:9;5390:22;5369:53;:::i;:::-;5359:63;;5315:117;5471:2;5497:53;5542:7;5533:6;5522:9;5518:22;5497:53;:::i;:::-;5487:63;;5442:118;5093:474;;;;;:::o;5573:118::-;5660:24;5678:5;5660:24;:::i;:::-;5655:3;5648:37;5573:118;;:::o;5697:222::-;5790:4;5828:2;5817:9;5813:18;5805:26;;5841:71;5909:1;5898:9;5894:17;5885:6;5841:71;:::i;:::-;5697:222;;;;:::o;5925:474::-;5993:6;6001;6050:2;6038:9;6029:7;6025:23;6021:32;6018:119;;;6056:79;;:::i;:::-;6018:119;6176:1;6201:53;6246:7;6237:6;6226:9;6222:22;6201:53;:::i;:::-;6191:63;;6147:117;6303:2;6329:53;6374:7;6365:6;6354:9;6350:22;6329:53;:::i;:::-;6319:63;;6274:118;5925:474;;;;;:::o;6405:180::-;6453:77;6450:1;6443:88;6550:4;6547:1;6540:15;6574:4;6571:1;6564:15;6591:410;6631:7;6654:20;6672:1;6654:20;:::i;:::-;6649:25;;6688:20;6706:1;6688:20;:::i;:::-;6683:25;;6743:1;6740;6736:9;6765:30;6783:11;6765:30;:::i;:::-;6754:41;;6944:1;6935:7;6931:15;6928:1;6925:22;6905:1;6898:9;6878:83;6855:139;;6974:18;;:::i;:::-;6855:139;6639:362;6591:410;;;;:::o;7007:191::-;7047:3;7066:20;7084:1;7066:20;:::i;:::-;7061:25;;7100:20;7118:1;7100:20;:::i;:::-;7095:25;;7143:1;7140;7136:9;7129:16;;7164:3;7161:1;7158:10;7155:36;;;7171:18;;:::i;:::-;7155:36;7007:191;;;;:::o;7204:194::-;7244:4;7264:20;7282:1;7264:20;:::i;:::-;7259:25;;7298:20;7316:1;7298:20;:::i;:::-;7293:25;;7342:1;7339;7335:9;7327:17;;7366:1;7360:4;7357:11;7354:37;;;7371:18;;:::i;:::-;7354:37;7204:194;;;;:::o;7404:180::-;7452:77;7449:1;7442:88;7549:4;7546:1;7539:15;7573:4;7570:1;7563:15;7590:185;7630:1;7647:20;7665:1;7647:20;:::i;:::-;7642:25;;7681:20;7699:1;7681:20;:::i;:::-;7676:25;;7720:1;7710:35;;7725:18;;:::i;:::-;7710:35;7767:1;7764;7760:9;7755:14;;7590:185;;;;:::o;7781:138::-;7818:7;7858:54;7851:5;7847:66;7836:77;;7781:138;;;:::o;7925:244::-;7965:3;7984:20;8002:1;7984:20;:::i;:::-;7979:25;;8018:20;8036:1;8018:20;:::i;:::-;8013:25;;8061:1;8058;8054:9;8047:16;;8084:54;8079:3;8076:63;8073:89;;;8142:18;;:::i;:::-;8073:89;7925:244;;;;:::o;8175:94::-;8208:8;8256:5;8252:2;8248:14;8227:35;;8175:94;;;:::o;8275:::-;8314:7;8343:20;8357:5;8343:20;:::i;:::-;8332:31;;8275:94;;;:::o;8375:100::-;8414:7;8443:26;8463:5;8443:26;:::i;:::-;8432:37;;8375:100;;;:::o;8481:157::-;8586:45;8606:24;8624:5;8606:24;:::i;:::-;8586:45;:::i;:::-;8581:3;8574:58;8481:157;;:::o;8644:79::-;8683:7;8712:5;8701:16;;8644:79;;;:::o;8729:157::-;8834:45;8854:24;8872:5;8854:24;:::i;:::-;8834:45;:::i;:::-;8829:3;8822:58;8729:157;;:::o;8892:397::-;9032:3;9047:75;9118:3;9109:6;9047:75;:::i;:::-;9147:2;9142:3;9138:12;9131:19;;9160:75;9231:3;9222:6;9160:75;:::i;:::-;9260:2;9255:3;9251:12;9244:19;;9280:3;9273:10;;8892:397;;;;;:::o;9295:180::-;9343:77;9340:1;9333:88;9440:4;9437:1;9430:15;9464:4;9461:1;9454:15;9481:332;9602:4;9640:2;9629:9;9625:18;9617:26;;9653:71;9721:1;9710:9;9706:17;9697:6;9653:71;:::i;:::-;9734:72;9802:2;9791:9;9787:18;9778:6;9734:72;:::i;:::-;9481:332;;;;;:::o;9819:93::-;9855:7;9895:10;9888:5;9884:22;9873:33;;9819:93;;;:::o;9918:60::-;9946:3;9967:5;9960:12;;9918:60;;;:::o;9984:140::-;10033:9;10066:52;10084:33;10093:23;10110:5;10093:23;:::i;:::-;10084:33;:::i;:::-;10066:52;:::i;:::-;10053:65;;9984:140;;;:::o;10130:129::-;10216:36;10246:5;10216:36;:::i;:::-;10211:3;10204:49;10130:129;;:::o;10265:330::-;10385:4;10423:2;10412:9;10408:18;10400:26;;10436:70;10503:1;10492:9;10488:17;10479:6;10436:70;:::i;:::-;10516:72;10584:2;10573:9;10569:18;10560:6;10516:72;:::i;:::-;10265:330;;;;;:::o;10601:197::-;10640:3;10659:19;10676:1;10659:19;:::i;:::-;10654:24;;10692:19;10709:1;10692:19;:::i;:::-;10687:24;;10734:1;10731;10727:9;10720:16;;10757:10;10752:3;10749:19;10746:45;;;10771:18;;:::i;:::-;10746:45;10601:197;;;;:::o;10804:442::-;10953:4;10991:2;10980:9;10976:18;10968:26;;11004:71;11072:1;11061:9;11057:17;11048:6;11004:71;:::i;:::-;11085:72;11153:2;11142:9;11138:18;11129:6;11085:72;:::i;:::-;11167;11235:2;11224:9;11220:18;11211:6;11167:72;:::i;:::-;10804:442;;;;;;:::o;11252:180::-;11300:77;11297:1;11290:88;11397:4;11394:1;11387:15;11421:4;11418:1;11411:15;11438:176;11470:1;11487:20;11505:1;11487:20;:::i;:::-;11482:25;;11521:20;11539:1;11521:20;:::i;:::-;11516:25;;11560:1;11550:35;;11565:18;;:::i;:::-;11550:35;11606:1;11603;11599:9;11594:14;;11438:176;;;;:::o;11620:233::-;11659:3;11682:24;11700:5;11682:24;:::i;:::-;11673:33;;11728:66;11721:5;11718:77;11715:103;;11798:18;;:::i;:::-;11715:103;11845:1;11838:5;11834:13;11827:20;;11620:233;;;:::o;11859:86::-;11894:7;11934:4;11927:5;11923:16;11912:27;;11859:86;;;:::o;11951:188::-;11989:3;12008:18;12024:1;12008:18;:::i;:::-;12003:23;;12040:18;12056:1;12040:18;:::i;:::-;12035:23;;12081:1;12078;12074:9;12067:16;;12104:4;12099:3;12096:13;12093:39;;;12112:18;;:::i;:::-;12093:39;11951:188;;;;:::o"}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betsize\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"LogDividend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogLate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hash\",\"type\":\"uint256\"}],\"name\":\"LogLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRecordWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"LogWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sadd\",\"type\":\"uint256\"}],\"name\":\"addHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addHashes128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betBlockNumberOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betHashOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"betOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betValueOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"changeAnimator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"coldStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coldStoreLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashBetMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashBetSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashFirst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashNext\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashesSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hotStore\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"houseKeeping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investBalanceMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investDirect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"play\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"playRandom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"playSystem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"putHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"putHashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxsum\",\"type\":\"uint256\"}],\"name\":\"setBetMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"setInvestStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletBlockOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletPeriodOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"won\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addHashes(uint256)\":{\"details\":\"Create hash data swap space\",\"params\":{\"_sadd\":\"Number of hashes to add (<=256)\"}},\"addHashes128()\":{\"details\":\"Create hash data swap space, add 128 hashes\"},\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens than an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"remaining\":\"A uint specifing the amount of tokens still avaible for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"balance\":\"An uint representing the amount owned by the passed address.\"}},\"betBlockNumberOf(address)\":{\"details\":\"Show block number of lottery run for the bet.\",\"params\":{\"_owner\":\"The address of the player.\"}},\"betHashOf(address)\":{\"details\":\"Show block number of lottery run for the bet.\",\"params\":{\"_owner\":\"The address of the player.\"}},\"betOf(address)\":{\"details\":\"Check if won in lottery\"},\"betValueOf(address)\":{\"details\":\"Show bet size.\",\"params\":{\"_owner\":\"The address of the player.\"}},\"changeAnimator(address)\":{\"details\":\"Change animator.\",\"params\":{\"_who\":\"The address of new animator.\"}},\"changeOwner(address)\":{\"details\":\"Change owner.\",\"params\":{\"_who\":\"The address of new owner.\"}},\"coldStore(uint256)\":{\"details\":\"Move funds to cold storageinvestBalance and walletBalance is protected from withdraw by ownerif funding is > 50% admin can withdraw only 0.25% of balance weakly\",\"params\":{\"_amount\":\"The amount of wei to move to cold storage\"}},\"disinvest()\":{\"details\":\"Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\"},\"dividendsBlocks()\":{\"details\":\"Print number of block till next expected dividend payment\"},\"hashesLength()\":{\"details\":\"Show length of allocated swap space\"},\"hotStore()\":{\"details\":\"Move funds to contract jackpot\"},\"houseKeeping()\":{\"details\":\"Update accounting\"},\"invest(address)\":{\"details\":\"Buy tokens with affiliate partner\",\"params\":{\"_partner\":\"Affiliate partner\"}},\"investDirect()\":{\"details\":\"Buy tokens\"},\"payDividends()\":{\"details\":\"Pay unpaid dividends\"},\"payWallet()\":{\"details\":\"Pay balance from wallet\"},\"play()\":{\"details\":\"Play in lottery\"},\"playRandom(address)\":{\"details\":\"Play in lottery with random numbers\",\"params\":{\"_partner\":\"Affiliate partner\"}},\"playSystem(uint256,address)\":{\"details\":\"Play in lottery with own numbers\",\"params\":{\"_partner\":\"Affiliate partner\"}},\"putHash()\":{\"details\":\"Fill hash data\"},\"putHashes(uint256)\":{\"details\":\"Fill hash data many times\",\"params\":{\"_num\":\"Number of iterations\"}},\"resetBet()\":{\"details\":\"Reset bet size accounting, to increase bet volume above safe limits\"},\"setBetMax(uint256)\":{\"details\":\"Set maximum bet size per block\",\"params\":{\"_maxsum\":\"The maximum bet size in wei.\"}},\"setInvestStart(uint256)\":{\"details\":\"Set ICO Start block.\",\"params\":{\"_when\":\"The block number of the ICO.\"}},\"transfer(address,uint256)\":{\"details\":\"transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint the amout of tokens to be transfered\"}},\"walletBalanceOf(address)\":{\"details\":\"Show balance of wallet\",\"params\":{\"_owner\":\"The address of the account.\"}},\"walletBlockOf(address)\":{\"details\":\"Show block number when withdraw can continue\",\"params\":{\"_owner\":\"The address of the account.\"}},\"walletPeriodOf(address)\":{\"details\":\"Show last dividend period processed\",\"params\":{\"_owner\":\"The address of the account.\"}},\"won()\":{\"details\":\"Check if won in lottery\"}},\"title\":\"SmartBillions contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"SmartBillions\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        payable(msg.sender).transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            payable(msg.sender).transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            payable(msg.sender).transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            payable(msg.sender).transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xdcda7ebdd967f24c4294aa1dafd507a90a37ebb12c9df873bc07c9b2fc72ef9d\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"StandardToken":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens than an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"remaining\":\"A uint specifing the amount of tokens still avaible for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"balance\":\"An uint representing the amount owned by the passed address.\"}},\"transfer(address,uint256)\":{\"details\":\"transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint the amout of tokens to be transfered\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"StandardToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.8, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        payable(msg.sender).transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            payable(msg.sender).transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            payable(msg.sender).transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            payable(msg.sender).transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xdcda7ebdd967f24c4294aa1dafd507a90a37ebb12c9df873bc07c9b2fc72ef9d\",\"license\":\"UNLICENSED\"}},\"version\":1}"}}},"errors":[{"component":"general","errorCode":"3628","formattedMessage":"Warning: This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.\n   --> SmartBillions.sol:121:1:\n    |\n121 | contract SmartBillions is StandardToken {\n    | ^ (Relevant source part starts here and spans across multiple lines).\nNote: The payable fallback function is defined here.\n   --> SmartBillions.sol:602:5:\n    |\n602 |     fallback() external payable {\n    |     ^ (Relevant source part starts here and spans across multiple lines).\n\n","message":"This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.","secondarySourceLocations":[{"end":21720,"file":"SmartBillions.sol","message":"The payable fallback function is defined here.","start":21163}],"severity":"warning","sourceLocation":{"end":27119,"file":"SmartBillions.sol","start":4372},"type":"Warning"}],"sources":{"SmartBillions.sol":{"id":0}}}

