{"contracts":{"OpenAddressLottery.sol":{"OpenAddressLottery":{"evm":{"deployedBytecode":{"object":"6080604052600436106100435760003560e01c806337354a68146100c257806341c0e1b51461012957806380ca7aec14610141578063d11711a21461015957610044565b5b5b67016345785d8a000034101580156100ab5750600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614155b156100bf576100be61016363ffffffff16565b5b5b005b3480156100cf5760006000fd5b50610113600480360360208110156100e75760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061030e565b6040518082815260200191505060405180910390f35b3480156101365760006000fd5b5061013f610388565b005b34801561014e5760006000fd5b50610157610400565b005b610161610163565b005b67016345785d8a00003410156101785761030c565b60001515600460005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff1615151415156101db5760006000fd5b6003600050546101f03361030e63ffffffff16565b14156102b1576001600460005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055506000600734029050478111156102675747905080505b3373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501580156102ae573d600060003e3d6000fd5b50505b6103e86002600050544303111561030b5761030a60405180608001604052804173ffffffffffffffffffffffffffffffffffffffff168152602001448152602001458152602001428152602001506104ec63ffffffff16565b5b5b565b600060088273ffffffffffffffffffffffffffffffffffffffff16600160005054604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120600060208110151561036a57fe5b1a60f81b60f81c60ff1681151561037d57fe5b06905080505b919050565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156103e55760006000fd5b3373ffffffffffffffffffffffffffffffffffffffff16ff5b565b600060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561045d5760006000fd5b610465610559565b3373ffffffffffffffffffffffffffffffffffffffff168160000190908181526020015050600143034060001c81602001909081815260200150504173ffffffffffffffffffffffffffffffffffffffff164402816040019090818152602001505060073a0281606001909081815260200150506104e8816104ec63ffffffff16565b505b565b8060000151816020015182604001518360600151604051602001808581526020018481526020018381526020018281526020019450505050506040516020818303038152906040528051906020012060001c60016000508190909055504360026000508190909055505b50565b604051806080016040528060008152602001600081526020016000815260200160008152602001509056fea2646970667358221220bcebe4b0668fc7cb1b1ef0d2045930f9629fb7d0c121701fd66d68c74846f24664736f6c63430007060033","sourceMap":"1131:3157:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4024:261;4165:9;4154;:20;;:41;;;;;4190:5;;;;;;;;;;;4178:17;;:10;:17;;;;4154:41;4151:127;;;4265:13;:11;:13;;:::i;:::-;4151:127;4024:261;1131:3157;2800:230;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;3435:109;;;;;;;;;;;;;:::i;:::-;;3554:460;;;;;;;;;;;;;:::i;:::-;;1900:890;;;:::i;:::-;;;1961:9;1951;:19;1948:43;;;1984:7;;1948:43;2104:5;2082:27;;:6;;;:18;2089:10;2082:18;;;;;;;;;;;;;;;;;;;;;;;;;:27;;;2074:36;;;;;;;;2168:11;;;;2132:32;2153:10;2132:20;:32;;:::i;:::-;:47;2129:442;;;2238:4;2217:6;;;:18;2224:10;2217:18;;;;;;;;;;;;;;;;:25;;;;;;;;;;;;;;;;;;2304:8;2323:1;2313:9;:11;2304:20;;2391:21;2387:3;:25;2384:107;;;2470:21;2466:25;;;;2384:107;2536:10;:19;;:24;2556:3;2536:24;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2129:442;;2616:4;2605:10;;;;2592:12;:23;:28;2589:161;;;2653:97;2660:89;;;;;;;;2682:14;2675:22;;2660:89;;;;2699:16;2660:89;;;;2717:14;2660:89;;;;2733:15;2660:89;;;;;2653:6;:97;;:::i;:::-;2589:161;1900:890;:::o;2800:230::-;2864:6;3022:1;2995:4;2990:10;;3002;;;;2973:40;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2963:51;;;;;;3015:1;2963:54;;;;;;;;;;;;2957:61;;2952:67;;:71;;;;;;;;2948:75;;;;2800:230;;;;:::o;3435:109::-;3488:5;;;;;;;;;;;3476:17;;:10;:17;;;3468:26;;;;;;;;3526:10;3513:24;;;3435:109;:::o;3554:460::-;3669:5;;;;;;;;;;;3657:17;;:10;:17;;;3649:26;;;;;;;;3741:23;;:::i;:::-;3794:10;3789:16;;3774:1;:12;;:31;;;;;;;;;3863:1;3848:12;:16;3838:27;3830:36;;3815:1;:12;;:51;;;;;;;;;3915:14;3908:22;;3891:16;:39;3876:1;:12;;:54;;;;;;;;;3969:1;3955:11;:15;3940:1;:12;;:30;;;;;;;;;3989:9;3996:1;3989:6;:9;;:::i;:::-;3554:460;;:::o;3040:385::-;3170:10;:21;;;3205:10;:21;;;3240:10;:21;;;3275:10;:21;;;3140:166;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;3130:177;;;;;;3122:186;;3109:10;;:199;;;;;;;3406:12;3393:10;;:25;;;;;;;3040:385;;:::o;-1:-1:-1:-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o"}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"forceReseed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"luckyNumberOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"participate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"OpenAddressLottery.sol\":\"OpenAddressLottery\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"OpenAddressLottery.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @vulnerable_at_lines: 93\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n/*\\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\\n * participate, they get the jackpot: 7 times the price of their bet.\\n * Of course one address can only win once. The owner regularly reseeds the secret\\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\\n * just wait for a reseed and try again!\\n *\\n * Jackpot chance:   1 in 8\\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\\n * Jackpot size: 7 times the ticket price\\n *\\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\\n * Keep in mind that your address can only win once\\n *\\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\\n\\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\\n*/\\n\\ncontract OpenAddressLottery{\\n    struct SeedComponents{\\n        uint component1;\\n        uint component2;\\n        uint component3;\\n        uint component4;\\n    }\\n    \\n    address owner; //address of the owner\\n    uint private secretSeed; //seed used to calculate number of an address\\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\\n        \\n    mapping (address => bool) winner; //keeping track of addresses that have already won\\n    \\n    constructor() {\\n        owner = msg.sender;\\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\\n    }\\n    \\n    function participate() public payable {\\n        if(msg.value<0.1 ether)\\n            return; //verify ticket price\\n        \\n        // make sure he hasn't won already\\n        require(winner[msg.sender] == false);\\n        \\n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\\n            winner[msg.sender] = true; // every address can only win once\\n            \\n            uint win=msg.value*7; //win = 7 times the ticket price\\n            \\n            if(win>address(this).balance) //if the balance isnt sufficient...\\n                win=address(this).balance; //...send everything we've got\\n            msg.sender.transfer(win);\\n        }\\n        \\n        if(block.number-lastReseed>1000) //reseed if needed\\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\\n    }\\n    \\n    function luckyNumberOfAddress(address addr) public view returns(uint n){\\n        // calculate the number of current address - 1 in 8 chance\\n        n = uint(uint8(keccak256(abi.encodePacked(uint(addr), secretSeed))[0])) % 8;\\n    }\\n    \\n    function reseed(SeedComponents memory components) internal {\\n        secretSeed = uint256(keccak256(abi.encodePacked(\\n            components.component1,\\n            components.component2,\\n            components.component3,\\n            components.component4\\n        ))); //hash the incoming parameters and use the hash to (re)initialize the seed\\n        lastReseed = block.number;\\n    }\\n    \\n    function kill() public {\\n        require(msg.sender==owner);\\n        \\n        selfdestruct(msg.sender);\\n    }\\n    \\n    function forceReseed() public { //reseed initiated by the owner - for testing purposes\\n        require(msg.sender==owner);\\n        // <yes> <report> OTHER - uninitialized storage\\n        SeedComponents memory s;\\n        s.component1 = uint(msg.sender);\\n        s.component2 = uint256(blockhash(block.number - 1));\\n        s.component3 = block.difficulty*(uint)(block.coinbase);\\n        s.component4 = tx.gasprice * 7;\\n        \\n        reseed(s); //reseed\\n    }\\n    \\n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\\n            participate();\\n    }\\n\\n}\\n\",\"keccak256\":\"0xfb63583d33e2376e55cc8279452d4e2a230daf99effcd0b5c47af96827341234\",\"license\":\"UNLICENSED\"}},\"version\":1}"}}},"errors":[{"component":"general","errorCode":"3628","formattedMessage":"OpenAddressLottery.sol:28:1: Warning: This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.\ncontract OpenAddressLottery{\n^ (Relevant source part starts here and spans across multiple lines).\nOpenAddressLottery.sol:102:5: The payable fallback function is defined here.\n    fallback() external payable { //if someone sends money without any function call, just assume he wanted to participate\n    ^ (Relevant source part starts here and spans across multiple lines).\n","message":"This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.","secondarySourceLocations":[{"end":4285,"file":"OpenAddressLottery.sol","message":"The payable fallback function is defined here.","start":4024}],"severity":"warning","sourceLocation":{"end":4288,"file":"OpenAddressLottery.sol","start":1131},"type":"Warning"}],"sources":{"OpenAddressLottery.sol":{"id":0}}}

