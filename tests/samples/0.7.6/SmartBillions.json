{"contracts":{"SmartBillions.sol":{"BasicToken":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"balance\":\"An uint representing the amount owned by the passed address.\"}},\"transfer(address,uint256)\":{\"details\":\"transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"BasicToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        msg.sender.transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            msg.sender.transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            msg.sender.transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x914b7d52a0f52737ce6b7db251ae368294d552bc22f9ca2f331cece912459581\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"ERC20":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"ERC20\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        msg.sender.transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            msg.sender.transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            msg.sender.transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x914b7d52a0f52737ce6b7db251ae368294d552bc22f9ca2f331cece912459581\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"ERC20Basic":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"ERC20Basic\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        msg.sender.transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            msg.sender.transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            msg.sender.transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x914b7d52a0f52737ce6b7db251ae368294d552bc22f9ca2f331cece912459581\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"SafeMath":{"evm":{"deployedBytecode":{"object":"73000000000000000000000000000000000000000030146080604052600436106023575b60006000fdfea26469706673582212204e93e01f599256ce773c8c124622489c37d7afb00d6a507c8f2c83ad43eb3adb64736f6c63430007060033","sourceMap":"320:244:0:-:0;;;;;;;;;;;;;;"}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"SafeMath\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        msg.sender.transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            msg.sender.transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            msg.sender.transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x914b7d52a0f52737ce6b7db251ae368294d552bc22f9ca2f331cece912459581\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"SmartBillions":{"evm":{"deployedBytecode":{"object":"60806040526004361061036f5760003560e01c8063814b3fe0116101c6578063c27509cf116100f7578063de46907111610095578063df1ead821161006f578063df1ead821461119f578063e4cc98a5146111b7578063e73cc2eb146111e3578063e76ece011461124a57610370565b8063de4690711461112f578063de88a3421461115b578063df12b94e1461117357610370565b8063cd88333e116100d1578063cd88333e14611027578063d6d2500814611064578063d9fa933514611090578063dd62ed3e146110a857610370565b8063c27509cf14610fc5578063c416436514610fcf578063cd0a314b14610ffb57610370565b8063a367d99a11610164578063b3470e971161013e578063b3470e9714610f37578063bc85171814610f63578063be1eefbf14610f8f578063bfba902914610f9957610370565b8063a367d99a14610e5b578063a6f9dae114610e87578063a9059cbb14610eda57610370565b8063904d2248116101a0578063904d224814610d2c57806393e84cd914610d9357806395d89b4114610db15780639ce962ca14610e4357610370565b8063814b3fe014610c325780638da5cb5b14610c835780638eecddcf14610cc557610370565b8063380f3087116102a0578063501895ae1161023e57806370a082311161021857806370a0823114610b0c57806370ccd92814610b735780637227c7ce14610b9f578063785ce7ca14610bcb57610370565b8063501895ae14610a2857806366ce3bd214610a795780636b48681814610ae057610370565b806340c73d171161027a57806340c73d1714610919578063413e90e71461096c5780634288d759146109a957806343146f3614610a1057610370565b8063380f3087146108355780633de8d340146108865780633e43b652146108b257610370565b806318160ddd1161030d57806326699576116102e75780632669957614610738578063313ce5671461079b57806331c2b6e6146107c757806337c430881461080957610370565b806318160ddd1461063657806323b872dd146106625780632406e9fa146106df57610370565b8063095ea7b311610349578063095ea7b31461056757806312c8052f146105c457806313e4b51f146105dc57806316d190e31461060a57610370565b806303f9c7931461045357806306fdde03146104985780630751076d1461052a57610370565b5b5b60003411156103d357600160086000505411156103be576103b9600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661128763ffffffff16565b6103ce565b6103cc611af563ffffffff16565b505b610451565b600060086000505414801561042d57506000600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054115b156104425761044133611b5c63ffffffff16565b5b610450611ee763ffffffff16565b5b005b6104966004803603602081101561046a5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611287565b005b3480156104a55760006000fd5b506104ae612838565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156104ef5780820151818401525b6020810190506104d3565b50505050905090810190601f16801561051c5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b3480156105375760006000fd5b506105656004803603602081101561054f5760006000fd5b8101908080359060200190929190505050612874565b005b3480156105745760006000fd5b506105c26004803603604081101561058c5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506128de565b005b3480156105d15760006000fd5b506105da611ee7565b005b3480156105e95760006000fd5b506105f2612a74565b60405180821515815260200191505060405180910390f35b3480156106175760006000fd5b50610620612b66565b6040518082815260200191505060405180910390f35b3480156106435760006000fd5b5061064c612b6f565b6040518082815260200191505060405180910390f35b34801561066f5760006000fd5b506106dd600480360360608110156106875760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050612b78565b005b610722600480360360208110156106f65760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612e87565b6040518082815260200191505060405180910390f35b6107856004803603604081101561074f5760006000fd5b8101908080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612eef565b6040518082815260200191505060405180910390f35b3480156107a85760006000fd5b506107b16132df565b6040518082815260200191505060405180910390f35b3480156107d45760006000fd5b506107dd6132e4565b604051808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b3480156108165760006000fd5b5061081f61330a565b6040518082815260200191505060405180910390f35b3480156108425760006000fd5b506108706004803603602081101561085a5760006000fd5b8101908080359060200190929190505050613310565b6040518082815260200191505060405180910390f35b3480156108935760006000fd5b5061089c61340e565b6040518082815260200191505060405180910390f35b3480156108bf5760006000fd5b50610903600480360360208110156108d75760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613485565b6040518082815260200191505060405180910390f35b3480156109265760006000fd5b5061096a6004803603602081101561093e5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061351a565b005b3480156109795760006000fd5b506109a7600480360360208110156109915760006000fd5b8101908080359060200190929190505050613610565b005b3480156109b65760006000fd5b506109fa600480360360208110156109ce5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061364c565b6040518082815260200191505060405180910390f35b348015610a1d5760006000fd5b50610a2661389a565b005b348015610a355760006000fd5b50610a6360048036036020811015610a4d5760006000fd5b8101908080359060200190929190505050613913565b6040518082815260200191505060405180910390f35b348015610a865760006000fd5b50610aca60048036036020811015610a9e5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061393c565b6040518082815260200191505060405180910390f35b348015610aed5760006000fd5b50610af66139d5565b6040518082815260200191505060405180910390f35b348015610b195760006000fd5b50610b5d60048036036020811015610b315760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506139de565b6040518082815260200191505060405180910390f35b348015610b805760006000fd5b50610b89613a32565b6040518082815260200191505060405180910390f35b348015610bac5760006000fd5b50610bb5613a47565b6040518082815260200191505060405180910390f35b348015610bd85760006000fd5b50610c1c60048036036020811015610bf05760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613a50565b6040518082815260200191505060405180910390f35b348015610c3f5760006000fd5b50610c6d60048036036020811015610c575760006000fd5b8101908080359060200190929190505050613abd565b6040518082815260200191505060405180910390f35b348015610c905760006000fd5b50610c99613ae6565b604051808273ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b348015610cd25760006000fd5b50610d1660048036036020811015610cea5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613b0c565b6040518082815260200191505060405180910390f35b348015610d395760006000fd5b50610d7d60048036036020811015610d515760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613b79565b6040518082815260200191505060405180910390f35b610d9b611af5565b6040518082815260200191505060405180910390f35b348015610dbe5760006000fd5b50610dc7613be6565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610e085780820151818401525b602081019050610dec565b50505050905090810190601f168015610e355780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b348015610e505760006000fd5b50610e59613c22565b005b348015610e685760006000fd5b50610e71613e6a565b6040518082815260200191505060405180910390f35b348015610e945760006000fd5b50610ed860048036036020811015610eac5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050613e73565b005b348015610ee75760006000fd5b50610f3560048036036040811015610eff5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050613f69565b005b348015610f445760006000fd5b50610f4d614327565b6040518082815260200191505060405180910390f35b348015610f705760006000fd5b50610f79614343565b6040518082815260200191505060405180910390f35b610f9761434c565b005b348015610fa65760006000fd5b50610faf61435d565b6040518082815260200191505060405180910390f35b610fcd614366565b005b348015610fdc5760006000fd5b50610fe561439a565b6040518082815260200191505060405180910390f35b3480156110085760006000fd5b506110116143a3565b6040518082815260200191505060405180910390f35b3480156110345760006000fd5b506110626004803603602081101561104c5760006000fd5b81019080803590602001909291905050506143ac565b005b3480156110715760006000fd5b5061107a6144f7565b6040518082815260200191505060405180910390f35b34801561109d5760006000fd5b506110a6614500565b005b3480156110b55760006000fd5b50611119600480360360408110156110cd5760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506145fd565b6040518082815260200191505060405180910390f35b34801561113c5760006000fd5b50611145614692565b6040518082815260200191505060405180910390f35b3480156111685760006000fd5b5061117161469b565b005b3480156111805760006000fd5b506111896146d0565b6040518082815260200191505060405180910390f35b3480156111ac5760006000fd5b506111b56146d9565b005b3480156111c45760006000fd5b506111cd614937565b6040518082815260200191505060405180910390f35b3480156111f05760006000fd5b50611234600480360360208110156112085760006000fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050614940565b6040518082815260200191505060405180910390f35b3480156112575760006000fd5b506112856004803603602081101561126f5760006000fd5b81019080803590602001909291905050506149a9565b005b60016008600050541180156112a757506005614000026008600050540143105b80156112bc5750600a60005054600960005054105b15156112c85760006000fd5b6000349050600960005054600a600050540381111561136f57600960005054600a600050540390508050600a600050546009600050819090905550600060086000508190909055503373ffffffffffffffffffffffffffffffffffffffff166108fc61133d8334614a4490919063ffffffff16565b9081150290604051600060405180830381858888f19350505050158015611369573d600060003e3d6000fd5b50611384565b80600960008282825054019250508190909055505b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16148061140c5750600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b1561152257600a8181151561141d57fe5b0460076000828282505401925050819090905550600a8181151561143d57fe5b0460056000506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff160217905550611705565b600260646005830281151561153357fe5b04026007600082828250540192505081909090555060646005820281151561155757fe5b0460056000506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff16021790555060646005820281151561164657fe5b04600560005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055505b600b60005054600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601a6101000a81548161ffff021916908361ffff160217905550600066038d7ea4c680008281151561178157fe5b049050600067016345785d8a00006010840281151561179c57fe5b049050600067016345785d8a0000600a85028115156117b757fe5b04905082600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282825054019250508190909055508160036000506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282825054019250508190909055508060036000506000600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282825054019250508190909055508082840101600060008282825054019250508190909055503373ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040518082815260200191505060405180910390a3600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a38473ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f36a013c86c271c703c54dee591bc768e347954a0a9a1937dd17f5a29e9a8e645866040518082815260200191505060405180910390a3505050505b50565b6000611b523343604051602001808373ffffffffffffffffffffffffffffffffffffffff1660601b8152601401828152602001925050506040516020818303038152906040528051906020012060001c6000612eef63ffffffff16565b9050611b59565b90565b6000600560005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601a9054906101000a900461ffff1661ffff1690506000600360005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050541480611c0f5750600081145b15611c8257600b60005054600560005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601a6101000a81548161ffff021916908361ffff16021790555050611ee4565b600b60005054811415611c955750611ee4565b600060006000505463ffffffff600360005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505402811515611cf257fe5b0490506000600090505b600b60005054831015611d4157600c60005083815481101515611d1b57fe5b906000526020600020900160005b505482028101905080505b8280600101935050611cfc565b63ffffffff81811515611d5057fe5b0490508050806007600082828250540192505081909090555080600560005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff16021790555082600560005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601a6101000a81548161ffff021916908361ffff1602179055508373ffffffffffffffffffffffffffffffffffffffff167fe1e87f40e4de2a6b68365d854f85940aad44d84933d399007702c6d340da445f8285604051808381526020018281526020019250505060405180910390a25050505b50565b6000600660005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000506040518060600160405290816000820160009054906101000a900477ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1681526020016000820160189054906101000a900463ffffffff1663ffffffff1663ffffffff16815260200160008201601c9054906101000a900463ffffffff1663ffffffff1663ffffffff168152602001505090506000816040015163ffffffff161415612131576040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815260200150600660005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff16021790555090505050612836565b6000816000015177ffffffffffffffffffffffffffffffffffffffffffffffff16148061216857506001816040015163ffffffff16145b156121815761217b613c2263ffffffff16565b50612836565b806040015163ffffffff164311151561219a5760006000fd5b43614000600a02826040015163ffffffff1601111515612346573373ffffffffffffffffffffffffffffffffffffffff167f770d64c654906ebab085526dd881064f61f0e5990caa94c94167eb29bc4645c6826040015143604051808363ffffffff1681526020018281526020019250505060405180910390a26040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815260200150600660005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff16021790555090505050612836565b60006000905060006000905061010083604001510163ffffffff1643101561239957826040015163ffffffff164060001c62ffffff16905080506123908382614a6263ffffffff16565b915081506125ad565b6000600e600050541115612418576123c0836040015163ffffffff16614c5d63ffffffff16565b9050805063010000008163ffffffff1614156123fe57826000015177ffffffffffffffffffffffffffffffffffffffffffffffff1691508150612413565b61240e8382614a6263ffffffff16565b915081505b6125ac565b3373ffffffffffffffffffffffffffffffffffffffff167f770d64c654906ebab085526dd881064f61f0e5990caa94c94167eb29bc4645c6846040015143604051808363ffffffff1681526020018281526020019250505060405180910390a26040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815260200150600660005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff160217905550905050505050612836565b5b6040518060600160405280600077ffffffffffffffffffffffffffffffffffffffffffffffff168152602001600063ffffffff168152602001600163ffffffff16815260200150600660005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff16021790555090505060008211156127cb573373ffffffffffffffffffffffffffffffffffffffff167e362509948ea59afac5c6fa93fea5327b624bc705a6574f4e9f26e9d8bd7ccc846020015163ffffffff168363ffffffff168560405180848152602001838152602001828152602001935050505060405180910390a2600d600050548211156127b75781600d6000508190909055503373ffffffffffffffffffffffffffffffffffffffff167f955214d16f858518f04c701d01a6e2f5668548b6be3c6f2f0f8981f77f2cfc06836040518082815260200191505060405180910390a25b6127c682614d0863ffffffff16565b612832565b3373ffffffffffffffffffffffffffffffffffffffff167f7375ed8230669ea9d64a9db629d7ce9501779604a67c95c0111377cf09f5b9b9846020015163ffffffff168363ffffffff16604051808381526020018281526020019250505060405180910390a25b5050505b565b6040518060400160405280601381526020017f536d61727442696c6c696f6e7320546f6b656e0000000000000000000000000081526020015081565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156128cd57fe5b8060126000508190909055505b5b50565b6000811415801561297557506000600460005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505414155b15151561297e57fe5b80600460005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000508190909055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040518082815260200191505060405180910390a35b5050565b60006000600f6000505490506000811480612a925750600a81014311155b15612aa1576000915050612b63565b6000610100431015612ab857600090508050612ac2565b6101004303905080505b80821015612ae9576000819050600a81811515612adb57fe5b068101905080508092508250505b6000600a600e600050548403811515612afe57fe5b049050612b118382614f2163ffffffff16565b601360005061400083811515612b2357fe5b06815481101515612b3057fe5b906000526020600020900160005b50819090905550600a8301600f60005081909090555060019350505050612b63565050505b90565b600d6000505481565b60006000505481565b606060048101600036905010151515612b8d57fe5b6000600460005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050549050612c2685611b5c63ffffffff16565b612c3584611b5c63ffffffff16565b612c8d83600360005060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505461503190919063ffffffff16565b600360005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050819090905550612d3083600360005060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054614a4490919063ffffffff16565b600360005060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050819090905550612d8e8382614a4490919063ffffffff16565b600460005060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000508190909055508373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef856040518082815260200191505060405180910390a3505b5b50505050565b6000612ee33343604051602001808373ffffffffffffffffffffffffffffffffffffffff1660601b8152601401828152602001925050506040516020818303038152906040528051906020012060001c83612eef63ffffffff16565b9050612eea565b919050565b6000612eff611ee763ffffffff16565b6000839050670de0b6b3a76400003411158015612f20575060126000505434105b1515612f2c5760006000fd5b60003411156132bb5760006008600050541415612f8557601434811515612f4f57fe5b04600c600050600b60005054815481101515612f6757fe5b906000526020600020900160005b8282825054019250508190909055505b600073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415156130a0576000606434811515612fc957fe5b049050806007600082828250540192505081909090555080600560005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff160217905550505b6003430160106000505410156130d05760034301601060005081909090555034601160005081909090555061311f565b6012600050546011600050541115613109576010600081815054809291906001019190509090555034601160005081909090555061311e565b34601160008282825054019250508190909055505b5b60405180606001604052803477ffffffffffffffffffffffffffffffffffffffffffffffff1681526020018262ffffff1663ffffffff16815260200160106000505463ffffffff16815260200150600660005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008201518160000160006101000a81548177ffffffffffffffffffffffffffffffffffffffffffffffff021916908377ffffffffffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160186101000a81548163ffffffff021916908363ffffffff160217905550604082015181600001601c6101000a81548163ffffffff021916908363ffffffff1602179055509050503373ffffffffffffffffffffffffffffffffffffffff167f063f4540040cf99a22f577ef321c170763020e6277e47275ed9b3d17ec14e13d8262ffffff166010600050543460405180848152602001838152602001828152602001935050505060405180910390a25b6132c9612a7463ffffffff16565b506010600050549150506132d956505b92915050565b600081565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b61400081565b60006000600e600050541480156133275750600082115b801561333557506140008211155b15156133415760006000fd5b60008260136000508054905001905061400081111561336257614000905080505b600060136000508054905090505b818110156133b75760136000506001908060018154018082558091505060019003906000526020600020900160005b909190919091509090555b8080600101915050613370565b506140006013600050805490501015156133f757600a438115156133d757fe5b064303600e600050819090905550600e60005054600f6000508190909055505b60136000508054905091505061340956505b919050565b6000600060086000505411156134275760009050613482565b6000614000600a02600e60005054430381151561344057fe5b049050600b6000505481111561345a576000915050613482565b614000600a02600e60005054430381151561347157fe5b06614000600a020391505061348256505b90565b6000600660005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160009054906101000a900477ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff169050613515565b919050565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561357357fe5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515156135ac57fe5b6135bb33611b5c63ffffffff16565b6135ca81611b5c63ffffffff16565b80600260006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b5b50565b6000600090505b818110156136475761362d612a7463ffffffff16565b15156136395750613649565b5b8080600101915050613617565b505b50565b60006000600660005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000506040518060600160405290816000820160009054906101000a900477ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1677ffffffffffffffffffffffffffffffffffffffffffffffff1681526020016000820160189054906101000a900463ffffffff1663ffffffff1663ffffffff16815260200160008201601c9054906101000a900463ffffffff1663ffffffff1663ffffffff168152602001505090506000816000015177ffffffffffffffffffffffffffffffffffffffffffffffff16148061378b57506001816040015163ffffffff1611155b8061379f5750806040015163ffffffff1643105b806137bb5750614000600a02816040015163ffffffff16014310155b156137ca576000915050613895565b61010081604001510163ffffffff16431015613806576137fe81826040015163ffffffff164060001c614a6263ffffffff16565b915050613895565b6000600e60005054111561388a57600061382f826040015163ffffffff16614c5d63ffffffff16565b905063010000008163ffffffff16141561386f57816000015177ffffffffffffffffffffffffffffffffffffffffffffffff169250505061389556613888565b61387f8282614a6263ffffffff16565b92505050613895565b505b600091505061389556505b919050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156138f357fe5b600343016010600050819090905550600060116000508190909055505b5b565b6013600050818154811061392657600080fd5b906000526020600020900160005b915090505481565b6000600560005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160009054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1679ffffffffffffffffffffffffffffffffffffffffffffffffffff1690506139d0565b919050565b600e6000505481565b6000600360005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050549050613a2d565b919050565b60006013600050805490509050613a44565b90565b60106000505481565b6000600560005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601c9054906101000a900463ffffffff1663ffffffff169050613ab8565b919050565b600c6000508181548110613ad057600080fd5b906000526020600020900160005b915090505481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600660005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601c9054906101000a900463ffffffff1663ffffffff169050613b74565b919050565b6000600660005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160189054906101000a900463ffffffff1663ffffffff169050613be1565b919050565b6040518060400160405280600481526020017f504c41590000000000000000000000000000000000000000000000000000000081526020015081565b6000600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160009054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1679ffffffffffffffffffffffffffffffffffffffffffffffffffff16118015613d1a575043600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601c9054906101000a900463ffffffff1663ffffffff1611155b15613e67576000600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160009054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff1679ffffffffffffffffffffffffffffffffffffffffffffffffffff1690506000600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160006101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508060076000828282505403925050819090905550613e6581614d0863ffffffff16565b505b5b565b60086000505481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515613ecc57fe5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614151515613f0557fe5b613f1433611b5c63ffffffff16565b613f2381611b5c63ffffffff16565b80600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505b5b50565b604060048101600036905010151515613f7e57fe5b613f8d33611b5c63ffffffff16565b613fe582600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054614a4490919063ffffffff16565b600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000508190909055503073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16141561420857614095600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16611b5c63ffffffff16565b61410f8260036000506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505461503190919063ffffffff16565b60036000506000600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050819090905550600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3614320565b61421783611b5c63ffffffff16565b61426f82600360005060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000505461503190919063ffffffff16565b600360005060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000508190909055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a35b5b5b505050565b6000614339608061331063ffffffff16565b9050614340565b90565b600f6000505481565b61435a61450063ffffffff16565b5b565b60126000505481565b614397600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1661128763ffffffff16565b5b565b600a6000505481565b60076000505481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561440557fe5b61441361450063ffffffff16565b600081118015614440575080600760005054600a60096009600050540281151561443957fe5b0401014710155b151561444c5760006000fd5b6002600a6000505481151561445d57fe5b0460096000505410151561449e576101904781151561447857fe5b048111158015614491575043619d806014600050540111155b151561449d5760006000fd5b5b3373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501580156144e5573d600060003e3d6000fd5b504360146000508190909055505b5b50565b60146000505481565b60016008600050541180156145215750600561400002600860005054014310155b1561453857600060086000508190909055506145fa565b6000600e6000505411156145f9576000614000600a02600e60005054430381151561455f57fe5b0490506002600c60005080549050038111156145a757600c6000506000908060018154018082558091505060019003906000526020600020900160005b909190919091509090555b600b60005054811180156145c057506000600860005054145b80156145db57506001600c6000508054905003600b60005054105b156145f757600b60008181505480929190600101919050909055505b505b5b5b565b6000600460005060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054905061468c565b92915050565b60116000505481565b60006008600050541415156146b05760006000fd5b6146bf33611b5c63ffffffff16565b6146cd613c2263ffffffff16565b5b565b60096000505481565b60006008600050541415156146ee5760006000fd5b6146fd33611b5c63ffffffff16565b600066038d7ea4c68000600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005054029050600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050546040518082815260200191505060405180910390a3600360005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600090558060096000828282505403925050819090905550600a6009820281151561486757fe5b04600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff160217905550614933613c2263ffffffff16565b505b565b600b6000505481565b6000600560005060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601a9054906101000a900461ffff1661ffff1690506149a4565b919050565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16141515614a0257fe5b6001600860005054148015614a1c57506000600e60005054115b8015614a2757508043105b1515614a335760006000fd5b8060086000508190909055505b5b50565b6000828211151515614a5257fe5b8183039050614a5c565b92915050565b6000600083602001519050600083821890506000600062f00000831662ffffff1614614a8f576000614a92565b60015b6000620f0000841662ffffff1614614aab576000614aae565b60015b600061f000851662ffffff1614614ac6576000614ac9565b60015b6000610f00861662ffffff1614614ae1576000614ae4565b60015b600060f0871662ffffff1614614afb576000614afe565b60015b6000600f881662ffffff1614614b15576000614b18565b60015b010101010160ff16905060068162ffffff161415614b5e57626acfc0866000015177ffffffffffffffffffffffffffffffffffffffffffffffff16029350505050614c57565b60058162ffffff161415614b9957614e20866000015177ffffffffffffffffffffffffffffffffffffffffffffffff16029350505050614c57565b60048162ffffff161415614bd4576101f4866000015177ffffffffffffffffffffffffffffffffffffffffffffffff16029350505050614c57565b60038162ffffff161415614c0e576019866000015177ffffffffffffffffffffffffffffffffffffffffffffffff16029350505050614c57565b60028162ffffff161415614c48576003866000015177ffffffffffffffffffffffffffffffffffffffffffffffff16029350505050614c57565b60009350505050614c57565050505b92915050565b60006000600a600e600050548403811515614c7457fe5b0490506000601360005061400083811515614c8b57fe5b06815481101515614c9857fe5b906000526020600020900160005b5054905060f081901c61400083811515614cbc57fe5b04141515614cd257630100000092505050614d03565b6000600a600e600050548603811515614ce757fe5b06905062ffffff8160180283901c169350505050614d03565050505b919050565b6000600247811515614d1657fe5b0490508181101515614d8d573373ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015614d69573d600060003e3d6000fd5b5066038d7ea4c68000821115614d8857614d8761450063ffffffff16565b5b614f1c565b60008183039050806007600082828250540192505081909090555080600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060005060000160008282829054906101000a900479ffffffffffffffffffffffffffffffffffffffffffffffffffff160192506101000a81548179ffffffffffffffffffffffffffffffffffffffffffffffffffff021916908379ffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055506202a3004301600560005060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600050600001601c6101000a81548163ffffffff021916908363ffffffff1602179055503373ffffffffffffffffffffffffffffffffffffffff166108fc839081150290604051600060405180830381858888f19350505050158015614f19573d600060003e3d6000fd5b50505b505b50565b600060f06140008363ffffffff16811515614f3857fe5b04901b60d862ffffff6009860163ffffffff164060001c16901b60c062ffffff6008870163ffffffff164060001c16901b60a862ffffff6007880163ffffffff164060001c16901b609062ffffff6006890163ffffffff164060001c16901b607862ffffff60058a0163ffffffff164060001c16901b606062ffffff60048b0163ffffffff164060001c16901b604862ffffff60038c0163ffffffff164060001c16901b603062ffffff60028d0163ffffffff164060001c16901b601862ffffff60018e0163ffffffff164060001c16901b62ffffff8d63ffffffff164060001c1617171717171717171717905061502b565b92915050565b60006000828401905083811015151561504657fe5b8091505061505056505b9291505056fea264697066735822122027afc325ff4f9cac77fbdfcc48015754648269d0dcc7dac5842c4069f728653464736f6c63430007060033","sourceMap":"4372:22711:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;21127:557;21180:1;21168:9;:13;21165:304;;;21211:1;21199:11;;;;:13;21196:243;;;21294:13;21301:5;;;;;;;;;;;21294:6;:13;;:::i;:::-;21196:243;;;21418:6;:4;:6;;:::i;:::-;;21196:243;21452:7;;21165:304;21543:1;21528:11;;;;:16;:42;;;;;21569:1;21548:8;;;:20;21557:10;21548:20;;;;;;;;;;;;;;;;;;:22;21528:42;21525:88;;;21585:26;21600:10;21585:14;:26;;:::i;:::-;21525:88;21622:5;:3;:5;;:::i;:::-;21127:557;4372:22711;13416:1956;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;4464:51;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;10268:89;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;3557:306;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;18897:2063;;;;;;;;;;;;;:::i;:::-;;26143:671;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;5555:22;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;599:23;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;2923:404;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;21997:172;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;22277:1326;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;4565:33;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;658:23;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;6081:39;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;23743:545;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;8925:353;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;8228:113;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;9687:194;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;26914:166;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;18021:818;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;10459:107;;;;;;;;;;;;;:::i;:::-;;5935:20;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;7497:123;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5604:25;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;2397:113;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;7295:96;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5737:24;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;8000:131;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5451:23;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;626:20;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;8711:122;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;8469:114;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;21734:152;;;:::i;:::-;;;;;;;;;;;;;;;;;;;4521:38;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12229:312;;;;;;;;;;;;;:::i;:::-;;5200:27;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;9403:185;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;1691:500;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;24366:87;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5677:24;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;11392:68;;;:::i;:::-;;5867:32;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;13236:71;;;:::i;:::-;;5347:43;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5108:29;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;10851:476;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;6148:29;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;11542:613;;;;;;;;;;;;;:::i;:::-;;4185:142;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5802:26;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;16043:132;;;;;;;;;;;;;:::i;:::-;;5286:29;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;15498:490;;;;;;;;;;;;;:::i;:::-;;5415:30;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;7739:133;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;9985:167;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;13416:1956;13571:1;13557:11;;;;:15;:64;;;;;13619:1;6115:5;13606:14;13591:11;;;;:30;13576:12;:45;13557:64;:100;;;;;13641:16;;;;13625:13;;;;:32;13557:100;13549:109;;;;;;;;13668:14;13685:9;13668:26;;13738:13;;;;13719:16;;;;:32;13707:9;:44;13704:373;;;13798:13;;;;13779:16;;;;:32;13767:44;;;;13841:16;;;;13825:13;;:32;;;;;;;13885:1;13871:11;;:15;;;;;;;13926:10;:19;;:45;13946:24;13960:9;13946;:13;;:24;;;;:::i;:::-;13926:45;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13704:373;;;14057:9;14040:13;;:26;;;;;;;;;;;;;;;13704:373;14109:1;14089:22;;:8;:22;;;:43;;;;14127:5;;;;;;;;;;;14115:17;;:8;:17;;;14089:43;14086:435;;;14176:2;14164:9;:14;;;;;;;;14147:13;;:31;;;;;;;;;;;;;;;14238:2;14226:9;:14;;;;;;;;14192:7;;;:14;14200:5;;;;;;;;;;;14192:14;;;;;;;;;;;;;;;;;:22;;;:49;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14086:435;;;14349:1;14342:3;14338:1;14326:9;:13;:19;;;;;;;;14325:25;14308:13;;:42;;;;;;;;;;;;;;;14414:3;14410:1;14398:9;:13;:19;;;;;;;;14364:7;;;:14;14372:5;;;;;;;;;;;14364:14;;;;;;;;;;;;;;;;;:22;;;:54;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14515:3;14511:1;14499:9;:13;:19;;;;;;;;14462:7;;;:17;14470:8;14462:17;;;;;;;;;;;;;;;;;:25;;;:57;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14086:435;14599:14;;;;14551:7;;;:19;14559:10;14551:19;;;;;;;;;;;;;;;;;:38;;;:63;;;;;;;;;;;;;;;;;;14656:18;14689:6;14677:9;:18;;;;;;;;14656:39;;14705:17;14742:6;14737:2;14725:9;:14;:23;;;;;;;;14705:43;;14760:20;14800:6;14795:2;14783:9;:14;:23;;;;;;;;14760:46;;14842:13;14818:8;;;:20;14827:10;14818:20;;;;;;;;;;;;;;;;:37;;;;;;;;;;;;;;;14884:12;14865:8;;;:15;14874:5;;;;;;;;;;;14865:15;;;;;;;;;;;;;;;;:31;;;;;;;;;;;;;;;14963:15;14941:8;;;:18;14950:8;;;;;;;;;;;14941:18;;;;;;;;;;;;;;;;:37;;;;;;;;;;;;;;;15066:15;15051:12;15035:13;:28;:46;15020:11;;:61;;;;;;;;;;;;;;;15116:10;15096:45;;15113:1;15096:45;;;15127:13;15096:45;;;;;;;;;;;;;;;;;;15193:5;;;;;;;;;;;15173:39;;15190:1;15173:39;;;15199:12;15173:39;;;;;;;;;;;;;;;;;;15264:8;;;;;;;;;;;15244:45;;15261:1;15244:45;;;15273:15;15244:45;;;;;;;;;;;;;;;;;;15346:8;15321:44;;15335:10;15321:44;;;15355:9;15321:44;;;;;;;;;;;;;;;;;;13416:1956;;;;;;:::o;21734:152::-;21774:4;21797:82;21840:10;21851:12;21823:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;21813:52;;;;;;21808:58;;21876:1;21797:10;:82;;:::i;:::-;21790:89;;;;21734:152;;:::o;16262:747::-;16328:9;16340:7;;;:13;16348:4;16340:13;;;;;;;;;;;;;;;;;:32;;;;;;;;;;;;16328:44;;;;16402:1;16386:8;;;:14;16395:4;16386:14;;;;;;;;;;;;;;;;;;:17;16385:32;;;;16415:1;16409:4;:7;16385:32;16382:136;;;16472:14;;;;16432:7;;;:13;16440:4;16432:13;;;;;;;;;;;;;;;;;:32;;;:55;;;;;;;;;;;;;;;;;;16501:7;;;16382:136;16536:14;;;;16530:4;:20;16527:56;;;16566:7;;;16527:56;16592:10;16635:11;;;;16622:10;16605:8;;;:14;16614:4;16605:14;;;;;;;;;;;;;;;;;;:27;:41;;;;;;;;16592:54;;16656:12;16671:1;16656:16;;16682:92;16692:14;;;;16687:4;:19;16682:92;;;16748:9;;;16758:4;16748:15;;;;;;;;;;;;;;;;;;;;;;16740:5;:23;16729:34;;;;;;16682:92;16707:6;;;;;;;16682:92;;;16804:10;16794:7;:20;;;;;;;;16783:32;;;;16842:7;16825:13;;:24;;;;;;;;;;;;;;;16892:7;16859;;;:13;16867:4;16859:13;;;;;;;;;;;;;;;;;:21;;;:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;16952:4;16910:7;;;:13;16918:4;16910:13;;;;;;;;;;;;;;;;;:32;;;:47;;;;;;;;;;;;;;;;;;16984:4;16972:30;;;16989:7;16997:4;16972:30;;;;;;;;;;;;;;;;;;;;;;;;16262:747;;;;;:::o;18897:2063::-;18929:17;18949:4;;;:16;18954:10;18949:16;;;;;;;;;;;;;;;;;18929:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;18995:1;18978:6;:15;;;:18;;;18975:149;;;19053:40;;;;;;;;19065:1;19053:40;;;;;;19077:1;19053:40;;;;;;19090:1;19053:40;;;;;;;19034:4;;;:16;19039:10;19034:16;;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;19107:7;;;18975:149;19151:1;19137:6;:12;;;:15;;;19136:41;;;;19175:1;19158:6;:15;;;:18;;;19136:41;19133:101;;;19192:11;:9;:11;;:::i;:::-;19217:7;;;19133:101;19264:6;:15;;;19251:28;;:12;:28;19243:37;;;;;;;;19370:12;6115:5;19350:2;:15;19331:6;:15;;;:35;;;:51;;19328:259;;;19443:10;19435:48;;;19454:6;:15;;;19470:12;19435:48;;;;;;;;;;;;;;;;;;;;;;;;;;19516:40;;;;;;;;19528:1;19516:40;;;;;;19540:1;19516:40;;;;;;19553:1;19516:40;;;;;;;19497:4;;;:16;19502:10;19497:16;;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;19570:7;;;19328:259;19596:10;19609:1;19596:14;;19620:11;19634:1;19620:15;;19677:3;19661:6;:15;;;:19;19648:32;;:12;:32;19645:884;;;19769:6;:15;;;19759:26;;;19754:32;;19740:47;;;;;;19809:29;19818:6;19832:4;19809:8;:29;;:::i;:::-;19801:37;;;;19645:884;;;19890:1;19880:9;;;;:11;19877:642;;;20038:24;20046:6;:15;;;20038:24;;:7;:24;;:::i;:::-;20031:31;;;;20091:9;20083:4;:17;;;20080:226;;;20175:6;:12;;;20170:18;;20162:26;;;;20080:226;;;20258:29;20267:6;20281:4;20258:8;:29;;:::i;:::-;20250:37;;;;20080:226;19877:642;;;20361:10;20353:48;;;20372:6;:15;;;20388:12;20353:48;;;;;;;;;;;;;;;;;;;;;;;;;;20438:40;;;;;;;;20450:1;20438:40;;;;;;20462:1;20438:40;;;;;;20475:1;20438:40;;;;;;;20419:4;;;:16;20424:10;20419:16;;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20496:8;;;;;19877:642;19645:884;20557:40;;;;;;;;20569:1;20557:40;;;;;;20581:1;20557:40;;;;;;20594:1;20557:40;;;;;;;20538:4;;;:16;20543:10;20538:16;;;;;;;;;;;;;;;;:59;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20616:1;20610:5;:7;20607:347;;;20645:10;20638:56;;;20661:6;:14;;;20656:20;;20682:4;20677:10;;20688:5;20638:56;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;20719:6;;;;20711:5;:14;20708:118;;;20753:5;20744:6;;:14;;;;;;;20794:10;20781:30;;;20805:5;20781:30;;;;;;;;;;;;;;;;;;20708:118;20839:10;20843:5;20839:3;:10;;:::i;:::-;20607:347;;;20900:10;20892:51;;;20916:6;:14;;;20911:20;;20937:4;20932:10;;20892:51;;;;;;;;;;;;;;;;;;;;;;;;20607:347;18897:2063;;;;:::o;4464:51::-;;;;;;;;;;;;;;;;;;;;;:::o;10268:89::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;;;10343:7:::1;10330:10;;:20;;;;;;;6855:1;10268:89:::0;;:::o;3557:306::-;3721:1;3711:6;:11;;3710:53;;;;;3761:1;3728:7;;;:19;3736:10;3728:19;;;;;;;;;;;;;;;;;:29;3748:8;3728:29;;;;;;;;;;;;;;;;;;:34;;3710:53;3708:56;3701:64;;;;;;3803:6;3771:7;;;:19;3779:10;3771:19;;;;;;;;;;;;;;;;;:29;3791:8;3771:29;;;;;;;;;;;;;;;;:38;;;;;;;3841:8;3820:38;;3829:10;3820:38;;;3851:6;3820:38;;;;;;;;;;;;;;;;;;3557:306;;;:::o;26143:671::-;26178:4;26194:10;26207:8;;;;26194:21;;26237:1;26228:5;:10;:40;;;;26266:2;26258:5;:10;26242:12;:26;;26228:40;26225:83;;;26291:5;26284:13;;;;;26225:83;26317:14;26357:3;26344:12;:16;26341:159;;;26420:1;26408:13;;;;26341:159;;;26486:3;26471:12;:18;26459:30;;;;26341:159;26520:9;26512:5;:17;26509:121;;;26545:8;26556:9;26545:20;;26592:2;26586:3;:8;;;;;;;;26579:15;;;;;;26616:3;26608:11;;;;26509:121;;26639:10;26674:2;26661:9;;;;26653:5;:17;26652:24;;;;;;;;26639:37;;26715:39;26733:5;26747;26715:10;:39;;:::i;:::-;26686:6;;;6115:5;26693;:18;;;;;;;;26686:26;;;;;;;;;;;;;;;;;;;;:68;;;;;;;26783:2;26775:5;:10;26764:8;;:21;;;;;;;26802:4;26795:12;;;;;;;26143:671;;;;;:::o;5555:22::-;;;;;;:::o;599:23::-;;;;;;:::o;2923:404::-;3018:6;1523:1;1516:4;:8;1497;;:15;;:27;;1490:35;;;;;;3032:15:::1;3050:7;;;:14;3058:5;3050:14;;;;;;;;;;;;;;;;;:26;3065:10;3050:26;;;;;;;;;;;;;;;;;;3032:44;;3082:21;3097:5;3082:14;:21;;:::i;:::-;3109:19;3124:3;3109:14;:19;;:::i;:::-;3150:25;3168:6;3150:8;;;:13;3159:3;3150:13;;;;;;;;;;;;;;;;;;:17;;:25;;;;:::i;:::-;3134:8;;;:13;3143:3;3134:13;;;;;;;;;;;;;;;;:41;;;;;;;3199:27;3219:6;3199:8;;;:15;3208:5;3199:15;;;;;;;;;;;;;;;;;;:19;;:27;;;;:::i;:::-;3181:8;;;:15;3190:5;3181:15;;;;;;;;;;;;;;;;:45;;;;;;;3261:22;3276:6;3261:10;:14;;:22;;;;:::i;:::-;3232:7;;;:14;3240:5;3232:14;;;;;;;;;;;;;;;;;:26;3247:10;3232:26;;;;;;;;;;;;;;;;:51;;;;;;;3310:3;3294:28;;3303:5;3294:28;;;3315:6;3294:28;;;;;;;;;;;;;;;;;;1532:1;;2923:404:::0;;;;;:::o;21997:172::-;22059:4;22082:80;22125:10;22136:12;22108:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22098:52;;;;;;22093:58;;22153:8;22082:10;:80;;:::i;:::-;22075:87;;;;21997:172;;;;:::o;22277:1326::-;22351:4;22367:5;:3;:5;;:::i;:::-;22413:14;22437:5;22413:30;;22474:7;22461:9;:20;;:46;;;;;22497:10;;;;22485:9;:22;22461:46;22453:55;;;;;;;;22533:1;22521:9;:13;22518:1003;;;22565:1;22552:11;;;;:14;22549:154;;;22671:2;22659:9;:14;;;;;;;;22630:9;;;22640:14;;;;22630:25;;;;;;;;;;;;;;;;;;;;:43;;;;;;;;;;;;;;;22549:154;22739:1;22719:22;;:8;:22;;;;22716:204;;;22761:8;22784:3;22772:9;:15;;;;;;;;22761:26;;22822:3;22805:13;;:20;;;;;;;;;;;;;;;22880:3;22843:7;;;:17;22851:8;22843:17;;;;;;;;;;;;;;;;;:25;;;:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22716:204;;22962:1;22947:12;:16;22936:8;;;;:27;22933:389;;;23009:1;22994:12;:16;22983:8;;:27;;;;;;;23041:9;23028:10;;:22;;;;;;;22933:389;;;23116:10;;;;23103;;;;:23;23100:208;;;23150:8;;:10;;;;;;;;;;;;;;;;;23195:9;23182:10;;:22;;;;;;;23100:208;;;23280:9;23266:10;;:23;;;;;;;;;;;;;;;23100:208;22933:389;23354:86;;;;;;;;23374:9;23354:86;;;;;;23402:7;23395:15;;23354:86;;;;;;23429:8;;;;23354:86;;;;;;;23335:4;;;:16;23340:10;23335:16;;;;;;;;;;;;;;;;:105;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23466:10;23459:51;;;23482:7;23477:13;;23491:8;;;;23500:9;23459:51;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22518:1003;23530:9;:7;:9;;:::i;:::-;;23587:8;;;;23580:16;;;;;22277:1326;;;;;;:::o;4565:33::-;4597:1;4565:33;:::o;658:23::-;;;;;;;;;;;;;:::o;6081:39::-;6115:5;6081:39;:::o;23743:545::-;23790:4;23827:1;23814:9;;;;:14;:27;;;;;23840:1;23832:5;:9;23814:27;:50;;;;;6115:5;23845;:19;;23814:50;23806:59;;;;;;;;23875:6;23900:5;23884:6;;;:13;;;;:21;23875:30;;6115:5;23918:1;:14;23915:57;;;6115:5;23947:14;;;;23915:57;23985:6;23992;;;:13;;;;23985:20;;23981:97;24008:1;24006;:3;23981:97;;;24053:6;;;24065:1;24053:14;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23981:97;24010:3;;;;;;;23981:97;;;;6115:5;24090:6;;;:13;;;;:25;;24087:164;;;24203:2;24188:12;:17;;;;;;;;24171:12;:35;24159:9;;:47;;;;;;;24231:9;;;;24220:8;;:20;;;;;;;24087:164;24267:6;;;:13;;;;24260:21;;;;;23743:545;;;;;:::o;8925:353::-;8975:4;9008:1;8994:11;;;;:15;8991:54;;;9032:1;9025:9;;;;8991:54;9054:11;6115:5;9098:2;:15;9084:9;;;;9069:12;:24;9068:46;;;;;;;;9054:60;;9136:14;;;;9127:6;:23;9124:62;;;9173:1;9166:9;;;;;9124:62;6115:5;9253:2;:15;9239:9;;;;9224:12;:24;9223:46;;;;;;;;6115:5;9203:2;:15;9202:68;9195:76;;;;;8925:353;;;:::o;8228:113::-;8287:4;8315;;;:12;8320:6;8315:12;;;;;;;;;;;;;;;;;:18;;;;;;;;;;;;8310:24;;8303:31;;;;8228:113;;;;:::o;9687:194::-;6924:8;;;;;;;;;;;6910:22;;:10;:22;;;6903:30;;;;;;9780:1:::1;9764:18;;:4;:18;;;;9757:26;;;;;;9793;9808:10;9793:14;:26;;:::i;:::-;9829:20;9844:4;9829:14;:20;;:::i;:::-;9870:4;9859:8;;:15;;;;;;;;;;;;;;;;;;6943:1;9687:194:::0;;:::o;26914:166::-;26963:6;26970:1;26963:8;;26981:93;26988:4;26986:1;:6;26981:93;;;27015:9;:7;:9;;:::i;:::-;27014:10;27011:53;;;27043:7;;;27011:53;26981:93;26993:3;;;;;;;26981:93;;;26914:166;;;:::o;18021:818::-;18073:4;18090:17;18110:4;;;:10;18115:4;18110:10;;;;;;;;;;;;;;;;;18090:30;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;18149:1;18135:6;:12;;;:15;;;18134:53;;;;18185:1;18168:6;:15;;;:18;;;;18134:53;:99;;;;18217:6;:15;;;18204:28;;:12;:28;18134:99;:166;;;;6115:5;18283:2;:15;18264:6;:15;;;:35;;;18250:12;:49;;18134:166;18130:205;;;18322:1;18315:9;;;;;18130:205;18376:3;18360:6;:15;;;:19;18347:32;;:12;:32;18344:171;;;18446:57;18455:6;18484;:15;;;18474:26;;;18469:32;;18446:8;:57;;:::i;:::-;18439:65;;;;;18344:171;18537:1;18527:9;;;;:11;18524:290;;;18553:11;18567:24;18575:6;:15;;;18567:24;;:7;:24;;:::i;:::-;18553:38;;18616:9;18608:4;:17;;;18605:206;;;18695:6;:12;;;18690:18;;18683:26;;;;;;18605:206;;;18766:29;18775:6;18789:4;18766:8;:29;;:::i;:::-;18759:37;;;;;;18605:206;18524:290;;18830:1;18823:9;;;;;18021:818;;;;;:::o;10459:107::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;;;10534:1:::1;10519:12;:16;10508:8;;:27;;;;;;;10558:1;10545:10;;:14;;;;;;;6855:1;10459:107:::0;:::o;5935:20::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;7497:123::-;7561:4;7589:7;;;:15;7597:6;7589:15;;;;;;;;;;;;;;;;;:23;;;;;;;;;;;;7584:29;;7577:36;;;;7497:123;;;;:::o;5604:25::-;;;;;;:::o;2397:113::-;2462:12;2489:8;;;:16;2498:6;2489:16;;;;;;;;;;;;;;;;;;2482:23;;;;2397:113;;;;:::o;7295:96::-;7342:4;7370:6;;;:13;;;;7358:26;;;;7295:96;;:::o;5737:24::-;;;;;;:::o;8000:131::-;8062:4;8090:7;;;:15;8098:6;8090:15;;;;;;;;;;;;;;;;;:33;;;;;;;;;;;;8085:39;;8078:46;;;;8000:131;;;;:::o;5451:23::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;626:20::-;;;;;;;;;;;;;:::o;8711:122::-;8776:4;8804;;;:12;8809:6;8804:12;;;;;;;;;;;;;;;;;:21;;;;;;;;;;;;8799:27;;8792:34;;;;8711:122;;;;:::o;8469:114::-;8527:4;8555;;;:12;8560:6;8555:12;;;;;;;;;;;;;;;;;:20;;;;;;;;;;;;8550:26;;8543:33;;;;8469:114;;;;:::o;4521:38::-;;;;;;;;;;;;;;;;;;;;;:::o;12229:312::-;12300:1;12270:7;;;:19;12278:10;12270:19;;;;;;;;;;;;;;;;;:27;;;;;;;;;;;;:31;;;:88;;;;;12346:12;12305:7;;;:19;12313:10;12305:19;;;;;;;;;;;;;;;;;:37;;;;;;;;;;;;:53;;;;12270:88;12267:268;;;12373:12;12388:7;;;:19;12396:10;12388:19;;;;;;;;;;;;;;;;;:27;;;;;;;;;;;;12373:42;;;;12459:1;12429:7;;;:19;12437:10;12429:19;;;;;;;;;;;;;;;;;:27;;;:31;;;;;;;;;;;;;;;;;;12491:7;12474:13;;:24;;;;;;;;;;;;;;;12512:12;12516:7;12512:3;:12;;:::i;:::-;12267:268;;12229:312;:::o;5200:27::-;;;;;;:::o;9403:185::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;;;9490:1:::1;9474:18;;:4;:18;;;;9467:26;;;;;;9503;9518:10;9503:14;:26;;:::i;:::-;9539:20;9554:4;9539:14;:20;;:::i;:::-;9577:4;9569:5;;:12;;;;;;;;;;;;;;;;;;6855:1;9403:185:::0;;:::o;1691:500::-;1767:6;1523:1;1516:4;:8;1497;;:15;;:27;;1490:35;;;;;;1781:26:::1;1796:10;1781:14;:26;;:::i;:::-;1836:32;1861:6;1836:8;;;:20;1845:10;1836:20;;;;;;;;;;;;;;;;;;:24;;:32;;;;:::i;:::-;1813:8;;;:20;1822:10;1813:20;;;;;;;;;;;;;;;;:55;;;;;;;1892:4;1877:20;;:3;:20;;;1874:313;;;1909:21;1924:5;;;;;;;;;;;1909:14;:21;;:::i;:::-;1958:27;1978:6;1958:8;;;:15;1967:5;;;;;;;;;;;1958:15;;;;;;;;;;;;;;;;;;:19;;:27;;;;:::i;:::-;1940:8;;;:15;1949:5;;;;;;;;;;;1940:15;;;;;;;;;;;;;;;;:45;;;;;;;2021:5;;;;;;;;;;;2000:35;;2009:10;2000:35;;;2028:6;2000:35;;;;;;;;;;;;;;;;;;1874:313;;;2062:19;2077:3;2062:14;:19;;:::i;:::-;2107:25;2125:6;2107:8;;;:13;2116:3;2107:13;;;;;;;;;;;;;;;;;;:17;;:25;;;;:::i;:::-;2091:8;;;:13;2100:3;2091:13;;;;;;;;;;;;;;;;:41;;;;;;;2168:3;2147:33;;2156:10;2147:33;;;2173:6;2147:33;;;;;;;;;;;;;;;;;;1874:313;1532:1;1691:500:::0;;;;:::o;24366:87::-;24408:4;24431:14;24441:3;24431:9;:14;;:::i;:::-;24424:22;;;;24366:87;;:::o;5677:24::-;;;;;;:::o;11392:68::-;11439:14;:12;:14;;:::i;:::-;11392:68;:::o;5867:32::-;;;;;;:::o;13236:71::-;13287:13;13294:5;;;;;;;;;;;13287:6;:13;;:::i;:::-;13236:71;:::o;5347:43::-;;;;;;:::o;5108:29::-;;;;;;:::o;10851:476::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;;;10913:14:::1;:12;:14;;:::i;:::-;10955:1;10945:7;:11;:90;;;;;11028:7;11012:13;;;;11006:2;11002:1;10986:13;;;;:17;:22;;;;;;;;10985:40;:50;10960:21;:75;;10945:90;10937:99;;;;;;;;11085:1;11066:16;;;;:20;;;;;;;;11049:13;;;;:37;;11046:199;;;11178:3;11154:21;:27;;;;;;;;11143:7;:38;;11142:91;;;;;11221:12;11202:15;11186:13;;;;:31;:47;;11142:91;11134:100;;;;;;;;11046:199;11254:10;:19;;:28;11274:7;11254:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;11308:12;11292:13;;:28;;;;;;;6855:1;10851:476:::0;;:::o;6148:29::-;;;;;;:::o;11542:613::-;11600:1;11586:11;;;;:15;:65;;;;;11649:1;6115:5;11636:14;11621:11;;;;:30;11605:12;:46;;11586:65;11583:566;;;11695:1;11681:11;;:15;;;;;;;11583:566;;;11777:1;11765:9;;;;:13;11762:377;;;11791:11;6115:5;11835:2;:15;11821:9;;;;11806:12;:24;11805:47;;;;;;;;11791:61;;11901:1;11882:9;;;:16;;;;:20;11873:6;:29;11870:92;;;11926:9;;;11941:1;11926:17;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;11870:92;11991:14;;;;11982:6;:23;:43;;;;;12024:1;12009:11;;;;:16;11982:43;:84;;;;;12065:1;12046:9;;;:16;;;;:20;12029:14;;;;:37;11982:84;11979:146;;;12090:14;;:16;;;;;;;;;;;;;;;;;11979:146;11762:377;;11583:566;11542:613;:::o;4185:142::-;4268:14;4297:7;;;:15;4305:6;4297:15;;;;;;;;;;;;;;;;;:25;4313:8;4297:25;;;;;;;;;;;;;;;;;;4290:32;;;;4185:142;;;;;:::o;5802:26::-;;;;;;:::o;16043:132::-;16109:1;16094:11;;;;:16;16086:25;;;;;;;;16121:26;16136:10;16121:14;:26;;:::i;:::-;16157:11;:9;:11;;:::i;:::-;16043:132;:::o;5286:29::-;;;;;;:::o;15498:490::-;15561:1;15546:11;;;;:16;15538:25;;;;;;;;15573:26;15588:10;15573:14;:26;;:::i;:::-;15609:22;15657:6;15634:8;;;:20;15643:10;15634:20;;;;;;;;;;;;;;;;;;:29;15609:54;;15706:1;15678:52;;15687:10;15678:52;;;15709:8;;;:20;15718:10;15709:20;;;;;;;;;;;;;;;;;;15678:52;;;;;;;;;;;;;;;;;;15764:8;;;:20;15773:10;15764:20;;;;;;;;;;;;;;;;15757:27;;;;15867:17;15850:13;;:34;;;;;;;;;;;;;;;15957:2;15953:1;15933:17;:21;:26;;;;;;;;15894:7;;;:19;15902:10;15894:19;;;;;;;;;;;;;;;;;:27;;;:66;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;15970:11;:9;:11;;:::i;:::-;15498:490;;:::o;5415:30::-;;;;;;:::o;7739:133::-;7802:4;7830:7;;;:15;7838:6;7830:15;;;;;;;;;;;;;;;;;:34;;;;;;;;;;;;7825:40;;7818:47;;;;7739:133;;;;:::o;9985:167::-;6839:5;;;;;;;;;;;6825:19;;:10;:19;;;6818:27;;;;;;10073:1:::1;10058:11;;;;:16;:33;;;;;10090:1;10078:9;;;;:13;10058:33;:57;;;;;10110:5;10095:12;:20;10058:57;10050:66;;;;;;;;10140:5;10126:11;;:19;;;;;;;6855:1;9985:167:::0;;:::o;341:101::-;393:4;417:1;412;:6;;405:14;;;;;;436:1;432;:5;425:12;;;;341:101;;;;;:::o;17040:923::-;17114:4;17150:14;17174:7;:15;;;17150:40;;17200:10;17223:5;17213:7;:15;17200:28;;17238:14;17508:1;17495:8;17489:3;:14;17488:21;;;:29;;17516:1;17488:29;;;17512:1;17488:29;17461:1;17449:7;17443:3;:13;17442:20;;;:28;;17469:1;17442:28;;;17465:1;17442:28;17415:1;17404:6;17398:3;:12;17397:19;;;:27;;17423:1;17397:27;;;17419:1;17397:27;17370:1;17360:5;17354:3;:11;17353:18;;;:26;;17378:1;17353:26;;;17374:1;17353:26;17326:1;17317:4;17311:3;:10;17310:17;;;:25;;17334:1;17310:25;;;17330:1;17310:25;17283:1;17275:3;17269;:9;17268:16;;;:24;;17291:1;17268:24;;;17287:1;17268:24;17267:70;:114;:159;:205;:252;17238:281;;;;17543:1;17532:7;:12;;;17529:78;;;17588:7;17571;:13;;;17566:19;;:29;17559:37;;;;;;;17529:78;17630:1;17619:7;:12;;;17616:76;;;17675:5;17658:7;:13;;;17653:19;;:27;17646:35;;;;;;;17616:76;17715:1;17704:7;:12;;;17701:74;;;17760:3;17743:7;:13;;;17738:19;;:25;17731:33;;;;;;;17701:74;17798:1;17787:7;:12;;;17784:73;;;17843:2;17826:7;:13;;;17821:19;;:24;17814:32;;;;;;;17784:73;17880:1;17869:7;:12;;;17866:72;;;17925:1;17908:7;:13;;;17903:19;;:23;17896:31;;;;;;;17866:72;17954:1;17947:9;;;;;;;17040:923;;;;;;;;:::o;25694:400::-;25746:6;25764:10;25800:2;25787:9;;;;25778:6;:18;25777:25;;;;;;;;25764:38;;25812:9;25824:6;;;6115:5;25831;:18;;;;;;;;25824:26;;;;;;;;;;;;;;;;;;;;;;25812:38;;25893:3;25885:4;:11;;6115:5;25863;:18;;;;;;;;:33;;25860:121;;;25919:9;25912:17;;;;;;25860:121;25990:10;26026:2;26013:9;;;;26004:6;:18;26003:25;;;;;;;;25990:38;;26077:8;26067:5;26062:2;:10;26053:4;:20;;26052:33;26038:49;;;;;;;25694:400;;;;;;;:::o;12547:616::-;12592:11;12630:1;12606:21;:25;;;;;;;;12592:39;;12654:7;12644:6;:17;;12641:516;;;12677:10;:19;;:28;12697:7;12677:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12732:8;12722:7;:18;12719:82;;;12772:14;:12;:14;;:::i;:::-;12719:82;12641:516;;;12839:16;12868:6;12858:7;:16;12839:35;;12905:11;12888:13;;:28;;;;;;;;;;;;;;;12969:11;12930:7;;;:19;12938:10;12930:19;;;;;;;;;;;;;;;;;:27;;;:51;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13057:16;13042:12;:31;12995:7;;;:19;13003:10;12995:19;;;;;;;;;;;;;;;;;:37;;;:79;;;;;;;;;;;;;;;;;;13119:10;:19;;:27;13139:6;13119:27;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;12641:516;;12547:616;;;:::o;24459:1229::-;24531:4;25676:3;6115:5;25651:6;25646:12;;:25;;;;;;;;25644:35;;25622:3;25608:8;25602:1;25595:6;:8;25585:19;;;25580:25;;:36;25578:47;;25511:3;25497:8;25491:1;25484:6;:8;25474:19;;;25469:25;;:36;25467:47;;25400:3;25386:8;25380:1;25373:6;:8;25363:19;;;25358:25;;:36;25356:47;;25289:3;25275:8;25269:1;25262:6;:8;25252:19;;;25247:25;;:36;25245:47;;25178:3;25164:8;25158:1;25151:6;:8;25141:19;;;25136:25;;:36;25134:47;;25068:2;25054:8;25048:1;25041:6;:8;25031:19;;;25026:25;;:36;25024:46;;24958:2;24944:8;24938:1;24931:6;:8;24921:19;;;24916:25;;:36;24914:46;;24848:2;24834:8;24828:1;24821:6;:8;24811:19;;;24806:25;;:36;24804:46;;24738:2;24724:8;24718:1;24711:6;:8;24701:19;;;24696:25;;:36;24694:46;;24626:8;24613:6;24603:19;;;24598:25;;:36;24596:146;:256;:366;:476;:587;:698;:809;:920;:1031;:1084;24588:1093;;;;24459:1229;;;;;:::o;445:117::-;497:4;509:6;522:1;518;:5;509:14;;541:1;536;:6;;529:14;;;;;;556:1;549:8;;;;;445:117;;;;;;:::o"}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocknumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"betsize\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"LogDividend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerBlockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBlockNumber\",\"type\":\"uint256\"}],\"name\":\"LogLate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hash\",\"type\":\"uint256\"}],\"name\":\"LogLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogRecordWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bethash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hash\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"LogWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sadd\",\"type\":\"uint256\"}],\"name\":\"addHashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addHashes128\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betBlockNumberOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betHashOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"betOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"betValueOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"changeAnimator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"coldStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coldStoreLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashBetMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashBetSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashFirst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashNext\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hashes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hashesSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hotStore\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"houseKeeping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investBalanceMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investDirect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"play\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"playRandom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hash\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"playSystem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"putHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"putHashes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxsum\",\"type\":\"uint256\"}],\"name\":\"setBetMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"setInvestStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletBlockOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"walletPeriodOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"won\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addHashes(uint256)\":{\"details\":\"Create hash data swap space\",\"params\":{\"_sadd\":\"Number of hashes to add (<=256)\"}},\"addHashes128()\":{\"details\":\"Create hash data swap space, add 128 hashes\"},\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens than an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"remaining\":\"A uint specifing the amount of tokens still avaible for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"balance\":\"An uint representing the amount owned by the passed address.\"}},\"betBlockNumberOf(address)\":{\"details\":\"Show block number of lottery run for the bet.\",\"params\":{\"_owner\":\"The address of the player.\"}},\"betHashOf(address)\":{\"details\":\"Show block number of lottery run for the bet.\",\"params\":{\"_owner\":\"The address of the player.\"}},\"betOf(address)\":{\"details\":\"Check if won in lottery\"},\"betValueOf(address)\":{\"details\":\"Show bet size.\",\"params\":{\"_owner\":\"The address of the player.\"}},\"changeAnimator(address)\":{\"details\":\"Change animator.\",\"params\":{\"_who\":\"The address of new animator.\"}},\"changeOwner(address)\":{\"details\":\"Change owner.\",\"params\":{\"_who\":\"The address of new owner.\"}},\"coldStore(uint256)\":{\"details\":\"Move funds to cold storageinvestBalance and walletBalance is protected from withdraw by ownerif funding is > 50% admin can withdraw only 0.25% of balance weakly\",\"params\":{\"_amount\":\"The amount of wei to move to cold storage\"}},\"disinvest()\":{\"details\":\"Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\"},\"dividendsBlocks()\":{\"details\":\"Print number of block till next expected dividend payment\"},\"hashesLength()\":{\"details\":\"Show length of allocated swap space\"},\"hotStore()\":{\"details\":\"Move funds to contract jackpot\"},\"houseKeeping()\":{\"details\":\"Update accounting\"},\"invest(address)\":{\"details\":\"Buy tokens with affiliate partner\",\"params\":{\"_partner\":\"Affiliate partner\"}},\"investDirect()\":{\"details\":\"Buy tokens\"},\"payDividends()\":{\"details\":\"Pay unpaid dividends\"},\"payWallet()\":{\"details\":\"Pay balance from wallet\"},\"play()\":{\"details\":\"Play in lottery\"},\"playRandom(address)\":{\"details\":\"Play in lottery with random numbers\",\"params\":{\"_partner\":\"Affiliate partner\"}},\"playSystem(uint256,address)\":{\"details\":\"Play in lottery with own numbers\",\"params\":{\"_partner\":\"Affiliate partner\"}},\"putHash()\":{\"details\":\"Fill hash data\"},\"putHashes(uint256)\":{\"details\":\"Fill hash data many times\",\"params\":{\"_num\":\"Number of iterations\"}},\"resetBet()\":{\"details\":\"Reset bet size accounting, to increase bet volume above safe limits\"},\"setBetMax(uint256)\":{\"details\":\"Set maximum bet size per block\",\"params\":{\"_maxsum\":\"The maximum bet size in wei.\"}},\"setInvestStart(uint256)\":{\"details\":\"Set ICO Start block.\",\"params\":{\"_when\":\"The block number of the ICO.\"}},\"transfer(address,uint256)\":{\"details\":\"transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint the amout of tokens to be transfered\"}},\"walletBalanceOf(address)\":{\"details\":\"Show balance of wallet\",\"params\":{\"_owner\":\"The address of the account.\"}},\"walletBlockOf(address)\":{\"details\":\"Show block number when withdraw can continue\",\"params\":{\"_owner\":\"The address of the account.\"}},\"walletPeriodOf(address)\":{\"details\":\"Show last dividend period processed\",\"params\":{\"_owner\":\"The address of the account.\"}},\"won()\":{\"details\":\"Check if won in lottery\"}},\"title\":\"SmartBillions contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"SmartBillions\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        msg.sender.transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            msg.sender.transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            msg.sender.transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x914b7d52a0f52737ce6b7db251ae368294d552bc22f9ca2f331cece912459581\",\"license\":\"UNLICENSED\"}},\"version\":1}"},"StandardToken":{"evm":{"deployedBytecode":{"object":"","sourceMap":""}},"metadata":"{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Function to check the amount of tokens than an owner allowed to a spender.\",\"params\":{\"_owner\":\"address The address which owns the funds.\",\"_spender\":\"address The address which will spend the funds.\"},\"returns\":{\"remaining\":\"A uint specifing the amount of tokens still avaible for the spender.\"}},\"approve(address,uint256)\":{\"details\":\"Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\",\"params\":{\"_spender\":\"The address which will spend the funds.\",\"_value\":\"The amount of tokens to be spent.\"}},\"balanceOf(address)\":{\"details\":\"Gets the balance of the specified address.\",\"params\":{\"_owner\":\"The address to query the the balance of.\"},\"returns\":{\"balance\":\"An uint representing the amount owned by the passed address.\"}},\"transfer(address,uint256)\":{\"details\":\"transfer token for a specified address\",\"params\":{\"_to\":\"The address to transfer to.\",\"_value\":\"The amount to be transferred.\"}},\"transferFrom(address,address,uint256)\":{\"details\":\"Transfer tokens from one address to another\",\"params\":{\"_from\":\"address The address which you want to send tokens from\",\"_to\":\"address The address which you want to transfer to\",\"_value\":\"uint the amout of tokens to be transfered\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"SmartBillions.sol\":\"StandardToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":false,\"cse\":false,\"deduplicate\":false,\"jumpdestRemover\":false,\"orderLiterals\":false,\"peephole\":false,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"SmartBillions.sol\":{\"content\":\"/*\\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\\n * Upgraded from Solidity 0.4 to 0.7, vulnerability may no longer exist\\n * @author: -\\n * @vulnerable_at_lines: 527,564,701,703,705,707,709,711,713,715,717,719\\n */\\n\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.0;\\n\\nlibrary SafeMath {\\n  function sub(uint a, uint b) internal pure returns (uint) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n  function add(uint a, uint b) internal pure returns (uint) {\\n    uint c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\\n\\nabstract contract ERC20Basic {\\n  uint public totalSupply;\\n  address public owner; //owner\\n  address public animator; //animator\\n  function balanceOf(address who) public view virtual returns (uint);\\n  function transfer(address to, uint value) public virtual;\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  function commitDividend(address who) internal virtual; // pays remaining dividend\\n}\\n\\nabstract contract ERC20 is ERC20Basic {\\n  function allowance(address owner, address spender) public view virtual returns (uint);\\n  function transferFrom(address from, address to, uint value) public virtual;\\n  function approve(address spender, uint value) public virtual;\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\nabstract contract BasicToken is ERC20Basic {\\n  using SafeMath for uint;\\n  mapping(address => uint) balances;\\n\\n  modifier onlyPayloadSize(uint size) {\\n     assert(msg.data.length >= size + 4);\\n     _;\\n  }\\n  /**\\n  * @dev transfer token for a specified address\\n  * @param _to The address to transfer to.\\n  * @param _value The amount to be transferred.\\n  */\\n  function transfer(address _to, uint _value) public override onlyPayloadSize(2 * 32) {\\n    commitDividend(msg.sender);\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    if(_to == address(this)) {\\n        commitDividend(owner);\\n        balances[owner] = balances[owner].add(_value);\\n        emit Transfer(msg.sender, owner, _value);\\n    }\\n    else {\\n        commitDividend(_to);\\n        balances[_to] = balances[_to].add(_value);\\n        emit Transfer(msg.sender, _to, _value);\\n    }\\n  }\\n  /**\\n  * @dev Gets the balance of the specified address.\\n  * @param _owner The address to query the the balance of.\\n  * @return balance An uint representing the amount owned by the passed address.\\n  */\\n  function balanceOf(address _owner) public view override returns (uint balance) {\\n    return balances[_owner];\\n  }\\n}\\n\\nabstract contract StandardToken is BasicToken, ERC20 {\\n  using SafeMath for uint;\\n  mapping (address => mapping (address => uint)) allowed;\\n\\n  /**\\n   * @dev Transfer tokens from one address to another\\n   * @param _from address The address which you want to send tokens from\\n   * @param _to address The address which you want to transfer to\\n   * @param _value uint the amout of tokens to be transfered\\n   */\\n  function transferFrom(address _from, address _to, uint _value) public override onlyPayloadSize(3 * 32) {\\n    uint _allowance = allowed[_from][msg.sender];\\n    commitDividend(_from);\\n    commitDividend(_to);\\n    balances[_to] = balances[_to].add(_value);\\n    balances[_from] = balances[_from].sub(_value);\\n    allowed[_from][msg.sender] = _allowance.sub(_value);\\n    emit Transfer(_from, _to, _value);\\n  }\\n  /**\\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\\n   * @param _spender The address which will spend the funds.\\n   * @param _value The amount of tokens to be spent.\\n   */\\n  function approve(address _spender, uint _value) public override {\\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\\n    allowed[msg.sender][_spender] = _value;\\n    emit Approval(msg.sender, _spender, _value);\\n  }\\n  /**\\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\\n   * @param _owner address The address which owns the funds.\\n   * @param _spender address The address which will spend the funds.\\n   * @return remaining A uint specifing the amount of tokens still avaible for the spender.\\n   */\\n  function allowance(address _owner, address _spender) public view override returns (uint remaining) {\\n    return allowed[_owner][_spender];\\n  }\\n}\\n\\n/**\\n * @title SmartBillions contract\\n */\\ncontract SmartBillions is StandardToken {\\n    using SafeMath for uint;\\n\\n    // metadata\\n    string public constant name = \\\"SmartBillions Token\\\";\\n    string public constant symbol = \\\"PLAY\\\";\\n    uint public constant decimals = 0;\\n\\n    // contract state\\n    struct Wallet {\\n        uint208 balance; // current balance of user\\n    \\tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\\n    \\tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\\n    }\\n    mapping (address => Wallet) wallets;\\n    struct Bet {\\n        uint192 value; // bet size\\n        uint32 betHash; // selected numbers\\n        uint32 blockNum; // blocknumber when lottery runs\\n    }\\n    mapping (address => Bet) bets;\\n\\n    uint public walletBalance = 0; // sum of funds in wallets\\n\\n    // investment parameters\\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\\n    uint public investBalance = 0; // funding from investors\\n    uint public investBalanceMax = 200000 ether; // maximum funding\\n    uint public dividendPeriod = 1;\\n    uint[] public dividends; // dividens collected per period, growing array\\n\\n    // betting parameters\\n    uint public maxWin = 0; // maximum prize won\\n    uint public hashFirst = 0; // start time of building hashes database\\n    uint public hashLast = 0; // last saved block of hashes\\n    uint public hashNext = 0; // next available bet block.number\\n    uint public hashBetSum = 0; // used bet volume of next block\\n    uint public hashBetMax = 5 ether; // maximum bet size per block\\n    uint[] public hashes; // space for storing lottery results\\n\\n    // constants\\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\\n\\n    // events\\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\\n    event LogLoss(address indexed player, uint bethash, uint hash);\\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\\n    event LogRecordWin(address indexed player, uint amount);\\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\\n    event LogDividend(address indexed investor, uint amount, uint period);\\n\\n    modifier onlyOwner() {\\n        assert(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyAnimator() {\\n        assert(msg.sender == animator);\\n        _;\\n    }\\n\\n    // constructor\\n    constructor() {\\n        owner = msg.sender;\\n        animator = msg.sender;\\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\\n        dividends.push(0); // not used\\n        dividends.push(0); // current dividend\\n    }\\n\\n/* getters */\\n\\n    /**\\n     * @dev Show length of allocated swap space\\n     */\\n    function hashesLength() external view returns (uint) {\\n        return uint(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Show balance of wallet\\n     * @param _owner The address of the account.\\n     */\\n    function walletBalanceOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].balance);\\n    }\\n\\n    /**\\n     * @dev Show last dividend period processed\\n     * @param _owner The address of the account.\\n     */\\n    function walletPeriodOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].lastDividendPeriod);\\n    }\\n\\n    /**\\n     * @dev Show block number when withdraw can continue\\n     * @param _owner The address of the account.\\n     */\\n    function walletBlockOf(address _owner) external view returns (uint) {\\n        return uint(wallets[_owner].nextWithdrawBlock);\\n    }\\n\\n    /**\\n     * @dev Show bet size.\\n     * @param _owner The address of the player.\\n     */\\n    function betValueOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].value);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betHashOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].betHash);\\n    }\\n\\n    /**\\n     * @dev Show block number of lottery run for the bet.\\n     * @param _owner The address of the player.\\n     */\\n    function betBlockNumberOf(address _owner) external view returns (uint) {\\n        return uint(bets[_owner].blockNum);\\n    }\\n\\n    /**\\n     * @dev Print number of block till next expected dividend payment\\n     */\\n    function dividendsBlocks() external view returns (uint) {\\n        if(investStart > 0) {\\n            return(0);\\n        }\\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\\n        if(period > dividendPeriod) {\\n            return(0);\\n        }\\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\\n    }\\n\\n/* administrative functions */\\n\\n    /**\\n     * @dev Change owner.\\n     * @param _who The address of new owner.\\n     */\\n    function changeOwner(address _who) external onlyOwner {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        owner = _who;\\n    }\\n\\n    /**\\n     * @dev Change animator.\\n     * @param _who The address of new animator.\\n     */\\n    function changeAnimator(address _who) external onlyAnimator {\\n        assert(_who != address(0));\\n        commitDividend(msg.sender);\\n        commitDividend(_who);\\n        animator = _who;\\n    }\\n\\n    /**\\n     * @dev Set ICO Start block.\\n     * @param _when The block number of the ICO.\\n     */\\n    function setInvestStart(uint _when) external onlyOwner {\\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\\n        investStart = _when;\\n    }\\n\\n    /**\\n     * @dev Set maximum bet size per block\\n     * @param _maxsum The maximum bet size in wei.\\n     */\\n    function setBetMax(uint _maxsum) external onlyOwner {\\n        hashBetMax = _maxsum;\\n    }\\n\\n    /**\\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\\n     */\\n    function resetBet() external onlyOwner {\\n        hashNext = block.number + 3;\\n        hashBetSum = 0;\\n    }\\n\\n    /**\\n     * @dev Move funds to cold storage\\n     * @dev investBalance and walletBalance is protected from withdraw by owner\\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\\n     * @param _amount The amount of wei to move to cold storage\\n     */\\n    function coldStore(uint _amount) external onlyOwner {\\n        houseKeeping();\\n        require(_amount > 0 && address(this).balance >= (investBalance * 9 / 10) + walletBalance + _amount);\\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\\n            require((_amount <= address(this).balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\\n        }\\n        msg.sender.transfer(_amount);\\n        coldStoreLast = block.number;\\n    }\\n\\n    /**\\n     * @dev Move funds to contract jackpot\\n     */\\n    function hotStore() payable external {\\n        houseKeeping();\\n    }\\n\\n/* housekeeping functions */\\n\\n    /**\\n     * @dev Update accounting\\n     */\\n    function houseKeeping() public {\\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\\n            investStart = 0; // start dividend payments\\n        }\\n        else {\\n            if(hashFirst > 0){\\n\\t\\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\\n                if(period > dividends.length - 2) {\\n                    dividends.push(0);\\n                }\\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\\n                    dividendPeriod++;\\n                }\\n            }\\n        }\\n    }\\n\\n/* payments */\\n\\n    /**\\n     * @dev Pay balance from wallet\\n     */\\n    function payWallet() public {\\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\\n            uint balance = wallets[msg.sender].balance;\\n            wallets[msg.sender].balance = 0;\\n            walletBalance -= balance;\\n            pay(balance);\\n        }\\n    }\\n\\n    function pay(uint _amount) private {\\n        uint maxpay = address(this).balance / 2;\\n        if(maxpay >= _amount) {\\n            msg.sender.transfer(_amount);\\n            if(_amount > 1e6 gwei) { // 1 finney\\n                houseKeeping();\\n            }\\n        }\\n        else {\\n            uint keepbalance = _amount - maxpay;\\n            walletBalance += keepbalance;\\n            wallets[msg.sender].balance += uint208(keepbalance);\\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\\n            msg.sender.transfer(maxpay);\\n        }\\n    }\\n\\n/* investment functions */\\n\\n    /**\\n     * @dev Buy tokens\\n     */\\n    function investDirect() payable external {\\n        invest(owner);\\n    }\\n\\n    /**\\n     * @dev Buy tokens with affiliate partner\\n     * @param _partner Affiliate partner\\n     */\\n    function invest(address _partner) public payable {\\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\\n        uint investing = msg.value;\\n        if(investing > investBalanceMax - investBalance) {\\n            investing = investBalanceMax - investBalance;\\n            investBalance = investBalanceMax;\\n            investStart = 0; // close investment round\\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\\n        }\\n        else{\\n            investBalance += investing;\\n        }\\n        if(_partner == address(0) || _partner == owner){\\n            walletBalance += investing / 10;\\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\\n        else{\\n            walletBalance += (investing * 5 / 100) * 2;\\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\\n        uint senderBalance = investing / 10**15;\\n        uint ownerBalance = investing * 16 / 10**17  ;\\n        uint animatorBalance = investing * 10 / 10**17  ;\\n        balances[msg.sender] += senderBalance;\\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\\n        emit Transfer(address(0),msg.sender,senderBalance); // for etherscan\\n        emit Transfer(address(0),owner,ownerBalance); // for etherscan\\n        emit Transfer(address(0),animator,animatorBalance); // for etherscan\\n        emit LogInvestment(msg.sender,_partner,investing);\\n    }\\n\\n    /**\\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\\n     */\\n    function disinvest() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        uint initialInvestment = balances[msg.sender] * 10**15;\\n        emit Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\\n        investBalance -= initialInvestment;\\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Pay unpaid dividends\\n     */\\n    function payDividends() external {\\n        require(investStart == 0);\\n        commitDividend(msg.sender);\\n        payWallet();\\n    }\\n\\n    /**\\n     * @dev Commit remaining dividends before transfer of tokens\\n     */\\n    function commitDividend(address _who) internal override {\\n        uint last = wallets[_who].lastDividendPeriod;\\n        if((balances[_who]==0) || (last==0)){\\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\\n            return;\\n        }\\n        if(last==dividendPeriod) {\\n            return;\\n        }\\n        uint share = balances[_who] * 0xffffffff / totalSupply;\\n        uint balance = 0;\\n        for(;last<dividendPeriod;last++) {\\n            balance += share * dividends[last];\\n        }\\n        balance = (balance / 0xffffffff);\\n        walletBalance += balance;\\n        wallets[_who].balance += uint208(balance);\\n        wallets[_who].lastDividendPeriod = uint16(last);\\n        emit LogDividend(_who,balance,last);\\n    }\\n\\n/* lottery functions */\\n\\n    function betPrize(Bet memory _player, uint24 _hash) private pure returns (uint) { // house fee 13.85%\\n        uint24 bethash = uint24(_player.betHash);\\n        uint24 hit = bethash ^ _hash;\\n        uint24 matches =\\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\\n        if(matches == 6){\\n            return(uint(_player.value) * 7000000);\\n        }\\n        if(matches == 5){\\n            return(uint(_player.value) * 20000);\\n        }\\n        if(matches == 4){\\n            return(uint(_player.value) * 500);\\n        }\\n        if(matches == 3){\\n            return(uint(_player.value) * 25);\\n        }\\n        if(matches == 2){\\n            return(uint(_player.value) * 3);\\n        }\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function betOf(address _who) external view returns (uint)  {\\n        Bet memory player = bets[_who];\\n        if( (player.value==0) ||\\n            (player.blockNum<=1) ||\\n            (block.number<player.blockNum) ||\\n            (block.number>=player.blockNum + (10 * hashesSize))){\\n            return(0);\\n        }\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            return(betPrize(player,uint24(uint(blockhash(player.blockNum)))));\\n        }\\n        if(hashFirst>0){\\n            uint32 hash = getHash(player.blockNum);\\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                return(uint(player.value));\\n            }\\n            else{\\n                return(betPrize(player,uint24(hash)));\\n            }\\n\\t}\\n        return(0);\\n    }\\n\\n    /**\\n     * @dev Check if won in lottery\\n     */\\n    function won() public {\\n        Bet memory player = bets[msg.sender];\\n        if(player.blockNum==0){ // create a new player\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        if((player.value==0) || (player.blockNum==1)){\\n            payWallet();\\n            return;\\n        }\\n        require(block.number>player.blockNum); // if there is an active bet, throw()\\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\\n            emit LogLate(msg.sender,player.blockNum,block.number);\\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n            return;\\n        }\\n        uint prize = 0;\\n        uint32 hash = 0;\\n        if(block.number<player.blockNum+256){\\n            // <yes> <report> BAD_RANDOMNESS\\n            hash = uint24(uint(blockhash(player.blockNum)));\\n            prize = betPrize(player,uint24(hash));\\n        }\\n        else {\\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\\n                hash = getHash(player.blockNum);\\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\\n                    prize = uint(player.value);\\n                }\\n                else{\\n                    prize = betPrize(player,uint24(hash));\\n                }\\n\\t    }\\n            else{\\n                emit LogLate(msg.sender,player.blockNum,block.number);\\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n                return();\\n            }\\n        }\\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\\n        if(prize>0) {\\n            emit LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\\n            if(prize > maxWin){\\n                maxWin = prize;\\n                emit LogRecordWin(msg.sender,prize);\\n            }\\n            pay(prize);\\n        }\\n        else{\\n            emit LogLoss(msg.sender,uint(player.betHash),uint(hash));\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ether to buy tokens during ICO\\n     * @dev or send less than 1 ether to contract to play\\n     * @dev or send 0 to collect prize\\n     */\\n    fallback() external payable {\\n        if(msg.value > 0){\\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\\n                invest(owner);\\n            }\\n            else{ // if not ICO running payment to contract is treated as play\\n                play();\\n            }\\n            return;\\n        }\\n        //check for dividends and other assets\\n        if(investStart == 0 && balances[msg.sender]>0){\\n            commitDividend(msg.sender);}\\n        won(); // will run payWallet() if nothing else available\\n    }\\n\\n    /**\\n     * @dev Play in lottery\\n     */\\n    function play() payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), address(0));\\n    }\\n\\n    /**\\n     * @dev Play in lottery with random numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playRandom(address _partner) payable public returns (uint) {\\n        return playSystem(uint(keccak256(abi.encodePacked(msg.sender,block.number))), _partner);\\n    }\\n\\n    /**\\n     * @dev Play in lottery with own numbers\\n     * @param _partner Affiliate partner\\n     */\\n    function playSystem(uint _hash, address _partner) public payable returns (uint) {\\n        won(); // check if player did not win\\n        uint24 bethash = uint24(_hash);\\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\\n        if(msg.value > 0){\\n            if(investStart==0) { // dividends only after investment finished\\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\\n            }\\n            if(_partner != address(0)) {\\n                uint fee = msg.value / 100;\\n                walletBalance += fee;\\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\\n            }\\n            if(hashNext < block.number + 3) {\\n                hashNext = block.number + 3;\\n                hashBetSum = msg.value;\\n            }\\n            else{\\n                if(hashBetSum > hashBetMax) {\\n                    hashNext++;\\n                    hashBetSum = msg.value;\\n                }\\n                else{\\n                    hashBetSum += msg.value;\\n                }\\n            }\\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\\n            emit LogBet(msg.sender,uint(bethash),hashNext,msg.value);\\n        }\\n        putHash(); // players help collecing data\\n        return(hashNext);\\n    }\\n\\n/* database functions */\\n\\n    /**\\n     * @dev Create hash data swap space\\n     * @param _sadd Number of hashes to add (<=256)\\n     */\\n    function addHashes(uint _sadd) public returns (uint) {\\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\\n        uint n = hashes.length + _sadd;\\n        if(n > hashesSize){\\n            n = hashesSize;\\n        }\\n        for(uint i=hashes.length;i<n;i++){ // make sure to burn gas\\n            hashes.push(1);\\n        }\\n        if(hashes.length>=hashesSize) { // assume block.number > 10\\n            hashFirst = block.number - ( block.number % 10);\\n            hashLast = hashFirst;\\n        }\\n        return(hashes.length);\\n    }\\n\\n    /**\\n     * @dev Create hash data swap space, add 128 hashes\\n     */\\n    function addHashes128() external returns (uint) {\\n        return(addHashes(128));\\n    }\\n\\n    function calcHashes(uint32 _lastb, uint32 _delta) private view returns (uint) {\\n        // <yes> <report> BAD_RANDOMNESS\\n        return( ( uint(blockhash(_lastb  )) & 0xFFFFFF )\\n        // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\\n            // <yes> <report> BAD_RANDOMNESS\\n            | ( ( uint(blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\\n            | ( ( uint(_delta) / hashesSize) << 240));\\n    }\\n\\n    function getHash(uint _block) private view returns (uint32) {\\n        uint delta = (_block - hashFirst) / 10;\\n        uint hash = hashes[delta % hashesSize];\\n        if(delta / hashesSize != hash >> 240) {\\n            return(0x1000000); // load failed, incorrect data in hashes\\n        }\\n        uint slotp = (_block - hashFirst) % 10;\\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\\n    }\\n\\n    /**\\n     * @dev Fill hash data\\n     */\\n    function putHash() public returns (bool) {\\n        uint lastb = hashLast;\\n        if(lastb == 0 || block.number <= lastb + 10) {\\n            return(false);\\n        }\\n        uint blockn256;\\n        if(block.number<256) { // useless test for testnet :-(\\n            blockn256 = 0;\\n        }\\n        else{\\n            blockn256 = block.number - 256;\\n        }\\n        if(lastb < blockn256) {\\n            uint num = blockn256;\\n            num += num % 10;\\n            lastb = num;\\n        }\\n        uint delta = (lastb - hashFirst) / 10;\\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\\n        hashLast = lastb + 10;\\n        return(true);\\n    }\\n\\n    /**\\n     * @dev Fill hash data many times\\n     * @param _num Number of iterations\\n     */\\n    function putHashes(uint _num) external {\\n        uint n=0;\\n        for(;n<_num;n++){\\n            if(!putHash()){\\n                return;\\n            }\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x914b7d52a0f52737ce6b7db251ae368294d552bc22f9ca2f331cece912459581\",\"license\":\"UNLICENSED\"}},\"version\":1}"}}},"errors":[{"component":"general","errorCode":"3628","formattedMessage":"SmartBillions.sol:121:1: Warning: This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.\ncontract SmartBillions is StandardToken {\n^ (Relevant source part starts here and spans across multiple lines).\nSmartBillions.sol:602:5: The payable fallback function is defined here.\n    fallback() external payable {\n    ^ (Relevant source part starts here and spans across multiple lines).\n","message":"This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.","secondarySourceLocations":[{"end":21684,"file":"SmartBillions.sol","message":"The payable fallback function is defined here.","start":21127}],"severity":"warning","sourceLocation":{"end":27083,"file":"SmartBillions.sol","start":4372},"type":"Warning"}],"sources":{"SmartBillions.sol":{"id":0}}}

