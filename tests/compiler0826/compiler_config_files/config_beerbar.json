{
  "language": "Solidity",
  "settings": {
    "debug": {
      "revertStrings": "debug",
      "debugInfo": [
        "*"
      ]
    },
    "optimizer": {
      "enabled": false
    },
    "viaIR": false,
    "evmVersion": "cancun",
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true,
      "appendCBOR": true
    },
    "modelChecker": {
      "engine": "none",
      "invariants": [
        "contract",
        "reentrancy"
      ],
      "showUnproved": true,
      "showUnsupported": true,
      "timeout": 0
    },
    "outputSelection": {
      "*": {
        "": [
          "*"
        ],
        "*": [
          "*"
        ]
      }
    }
  },
  "sources": {
    "contracts/BeerBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IBeerBar.sol\";\nimport \"./BeerToken.sol\";\nimport \"./IERC223Recipient.sol\";\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n\n//contract BeerBar is IBeerBar, <Token-Recipient>\ncontract BeerBar is IBeerBar, AccessControl {\n    BeerToken public beerTokenContract;\n    bytes32 public constant OWNER = keccak256(\"OWNER\");\n    bytes32 public constant BARKEEPER = keccak256(\"BARKEEPER\");\n    bool public _barIsOpen;\n    uint public _beerPrice;\n\n    mapping(address => uint) orders;\n\n\n    constructor () {\n        _grantRole(OWNER, msg.sender);\n        _grantRole(0x0000000000000000000000000000000000000000000000000000000000000000, msg.sender);\n    }\n\n    // ROLES\n    // * Only owners can add new owners\n    // * Owners can only renounce themselves again\n    function isOwner(address account) external view returns (bool) {\n        return hasRole(OWNER, account);\n    }\n\n    function addOwner(address account) external {\n        require(hasRole(OWNER, msg.sender), \"Only owners can add new owners\");\n        _grantRole(OWNER, account);\n        emit OwnerAdded(account);\n    }\n\n    function renounceOwner() external {\n        require(hasRole(OWNER, msg.sender), \"Owners can only renounce themselves again\");\n        _revokeRole(OWNER, msg.sender);\n        emit OwnerRemoved(msg.sender);\n    }\n\n    // * Barkeepers have to be set by owners\n    // * Barkeepers can be revoked by owners\n    // * Barkeepers can renounce themselves\n    function isBarkeeper(address account) external view returns (bool) {\n        return hasRole(BARKEEPER, account);\n    }\n\n    function addBarkeeper(address account) external {\n        require(hasRole(OWNER, msg.sender), \"Barkeepers have to be set by owners\");\n         _grantRole(BARKEEPER, account);\n         emit BarkeeperAdded(account);\n    }\n\n    function revokeBarkeeper(address account) external {\n        require(hasRole(OWNER, msg.sender), \"Barkeepers can be revoked by owners\");\n        _revokeRole(BARKEEPER, msg.sender);\n        emit BarkeeperRemoved(account);\n    }\n\n    function renounceBarkeeper() external {\n        require(hasRole(BARKEEPER, msg.sender), \"Barkeepers can renounce themselves\");\n        _revokeRole(BARKEEPER, msg.sender);\n        emit BarkeeperRemoved(msg.sender);\n    }\n\n    // * The bar uses its own tokens as local currency.\n    //   Connect the bar contract with the token contract.\n    // * This can only be done by owners\n    function setBeerTokenContractAddress(address addr) external {\n        require(hasRole(OWNER, msg.sender), \"This can only be done by owners\");\n        beerTokenContract = BeerToken(addr);\n    }\n    // * Show which beer is served\n    function beerTokenContractAddress() external view returns(address) {\n        return address(beerTokenContract);\n    }\n\n    // * The bar has opening hours during which beer can be ordered and served\n    // * The bar is opened and closed by barkeepers\n    function openBar() external {\n        require(hasRole(BARKEEPER, msg.sender), \" The bar is opened and closed by barkeepers\");\n        _barIsOpen = true;\n        emit BarOpened();\n    }\n\n    function closeBar() external virtual {\n        require(hasRole(BARKEEPER, msg.sender), \" The bar is opened and closed by barkeepers\");\n        _barIsOpen = false;\n        emit BarClosed();\n    }\n\n    function barIsOpen() external view returns (bool) {\n        return _barIsOpen;\n    }\n\n\n\n    // Both, supply and order, have to be implemented in a token fallback function\n    function tokenReceived(address _from, uint _value, bytes memory _data) public virtual {\n        require(msg.sender == address(beerTokenContract),\"Wrong token\");\n        if(keccak256(_data) == hex\"b308cfbb7d2d38db3a215f9728501ac69445a6afbee328cdeae4e23db54b850a\") {\n            require(hasRole(OWNER, tx.origin) ,\"Only the token owner can supply\");\n            emit BeerSupplied(_from, _value);\n        } else if(keccak256(_data) == hex\"e8e77626586f73b955364c7b4bbf0bb7f7685ebd40e852b164633a4acbd3244c\") {\n            require(!hasRole(BARKEEPER, msg.sender) && !hasRole(OWNER, msg.sender), \"Only customers can order\");\n            require(_barIsOpen, \"Bar is closed\");\n            orders[_from] += _value;\n            emit BeerOrdered(_from, _value);\n        }\n    }\n\n    // * Beer that has been ordered will be served by barkeepers\n    // * Beer can only be served while the bar is open\n    // * Served beer has to be burned by the token contract\n    function serveBeer(address customer, uint amount) external {\n        require(_barIsOpen, \" Beer can only be served while the bar is open\");\n        require(hasRole(BARKEEPER, msg.sender), \" Only barkeepers can serve beer\");\n        require(orders[customer] >= amount, \" The customer did not order that much!\");\n        orders[customer] -= amount;\n        beerTokenContract.burn(amount);\n    }\n\n    // * Orders that haven't yet been processed may be canceled by the\n    //   customer, who will get back the tokens\n    // * This triggers the event BeerCanceled\n    // * Orders can be canceled at any time\n    function cancelOrder(uint amount) external {\n        require(orders[msg.sender] >= amount);\n        require(beerTokenContract.transfer(msg.sender, amount),\"Failed to transfer tokens\");\n        orders[msg.sender] -= amount;\n        emit BeerCanceled(msg.sender, amount);\n\n    }\n\n\n    // * Get pending orders for a customer\n    function pendingBeer(address customer) external view returns (uint256) {\n        return orders[customer];\n    }\n\n    // * Beer price can only be changed by owners when the bar is closed\n    function setBeerPrice(uint256 price) external {\n        require(!_barIsOpen, \" Beer price can only be changed when the bar is closed\");\n        require(hasRole(OWNER, msg.sender), \" Beer price can only be changed by owners \");\n        _beerPrice = price;\n    }\n\n    function getBeerPrice() external view returns(uint256) {\n        return _beerPrice;\n    }\n\n    // * Customers may buy tokens for Ether\n    // * If the supplied Ether is not divisible by the beer price\n    //   the rest is kept as a tip. The caller (like the web interface)\n    //   can check that the value is a multiple of the beer price.\n    function buyToken() external payable {\n        require(_beerPrice > 0, \" Beer price has not been set\");\n        require(beerTokenContract.transfer(msg.sender, (msg.value-(msg.value % _beerPrice))/_beerPrice),\"Failed to transfer\");\n        //require(beerTokenContract.mint(msg.sender, (msg.value-(msg.value % _beerPrice))/_beerPrice),\"Failed to mint\");\n    }\n\n    // * `amount` (in Wei) of the Ether stored in the contract is transferred to\n    //   `receiver`, provided `amount` does not exceed the balance of the contract\n    // * Only owners are allowed to do this\n    function payout(address payable receiver, uint256 amount) external {\n        require(hasRole(OWNER, msg.sender), \"  Only owners are allowed to do this\");\n        (bool success, ) = receiver.call{value: amount}(\"\");\n        require(success, \"Failed to send Ether\");\n    }\n\n\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "contracts/IERC223Recipient.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\n /**\r\n * @title Contract that will work with ERC223 tokens.\r\n */\r\n \r\nabstract contract IERC223Recipient {\r\n\r\n\r\n struct ERC223TransferInfo\r\n    {\r\n        address token_contract;\r\n        address sender;\r\n        uint256 value;\r\n        bytes   data;\r\n    }\r\n    \r\n    ERC223TransferInfo private tkn;\r\n    \r\n/**\r\n * @dev Standard ERC223 function that will handle incoming token transfers.\r\n *\r\n * @param _from  Token sender address.\r\n * @param _value Amount of tokens.\r\n * @param _data  Transaction metadata.\r\n */\r\n    function tokenReceived(address _from, uint _value, bytes memory _data) public virtual\r\n    {\r\n        /**\r\n         * @dev Note that inside of the token transaction handler the actual sender of token transfer is accessible via the tkn.sender variable\r\n         * (analogue of msg.sender for Ether transfers)\r\n         * \r\n         * tkn.value - is the amount of transferred tokens\r\n         * tkn.data  - is the \"metadata\" of token transfer\r\n         * tkn.token_contract is most likely equal to msg.sender because the token contract typically invokes this function\r\n        */\r\n        tkn.token_contract = msg.sender;\r\n        tkn.sender         = _from;\r\n        tkn.value          = _value;\r\n        tkn.data           = _data;\r\n        \r\n        // ACTUAL CODE\r\n    }\r\n}\r\n"
    },
    "contracts/BeerToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IBeerToken.sol\";\nimport \"./Address.sol\";\nimport \"./IERC223Recipient.sol\";\n\ncontract BeerToken is IBeerToken {\n\n    address private owner;\n    uint public total;\n    mapping(address => uint) public tokens;\n\n    constructor() {\n      owner = msg.sender;\n    }\n\n    // * Default attributes of your token\n    function name() external view returns (string memory) {\n      return \"Corns\";\n    }\n\n    function symbol() external view returns (string memory) {\n      return \"Corns\";\n    }\n\n    // * Our BeerToken is not divisible\n    function decimals() external view returns (uint8) {\n      return 0;\n    }\n\n    // * Show the total supply of tokens\n    function totalSupply() external view returns (uint256) {\n      return total;\n    }\n\n    // * Show the token balance of the address\n    function balanceOf(address who) external view returns (uint256) {\n      return tokens[who];\n    }\n\n    // * Basic functionality for transferring tokens to user.\n    //   The token contract keeps track of the token balances.\n    // * Token must not be lost! Make sure they can only be transferred to addresses,\n    //   who also support the receiving of tokens.\n    function transfer(address to, uint256 value) external returns (bool success) {\n      require(tokens[msg.sender] >= value);\n      bytes memory _empty = hex\"00000000\";\n      tokens[msg.sender] = tokens[msg.sender] - value;\n      tokens[to] = tokens[to] + value;\n      if(Address.isContract(to)) {\n         IERC223Recipient(to).tokenReceived(msg.sender, value, _empty);\n      }\n      emit Transfer(msg.sender, to, value);\n      //emit TransferData(_empty);\n      return true;\n    }\n\n    function transfer(address to, uint256 value, bytes calldata data) external returns (bool success) {\n      require(tokens[msg.sender] >= value);\n      tokens[msg.sender] = tokens[msg.sender] - value;\n      tokens[to] = tokens[to] + value;\n      if(Address.isContract(to)) {\n         IERC223Recipient(to).tokenReceived(msg.sender, value, data);\n      }\n      emit Transfer(msg.sender, to, value);\n      //emit TransferData(_data);\n      return true;\n    }\n\n    // * Tokens can be minted by the owner of the token contract\n    function mint(address account, uint256 value) external returns (bool success) {\n      require(owner == msg.sender,\"Only owner can mint\");\n      tokens[account] += value;\n      total += value;\n      emit Transfer(msg.sender, account, value);\n      return true;\n    }\n\n    // * Tokens can be burned and therefore \"destroyed\"\n    function burn(uint256 value) external {\n      require(tokens[msg.sender] >= value);\n      tokens[msg.sender] -= value;\n      total -= value;\n    }\n\n}\n"
    },
    "contracts/IBeerBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBeerBar {\n\n    // ROLES\n    // * Only owners can add new owners\n    // * Owners can only renounce themselves again\n    function isOwner(address account) external view returns (bool);\n    function addOwner(address account) external;\n    function renounceOwner() external;\n    event OwnerAdded(address account);\n    event OwnerRemoved(address account);\n    // * Barkeepers have to be set by owners\n    // * Barkeepers can be revoked by owners\n    // * Barkeepers can renounce themselves\n    function isBarkeeper(address account) external view returns (bool);\n    function addBarkeeper(address account) external;\n    function revokeBarkeeper(address account) external;\n    function renounceBarkeeper() external;\n    event BarkeeperAdded(address account);\n    event BarkeeperRemoved(address account);\n\n    // * The bar uses its own tokens as local currency.\n    //   Connect the bar contract with the token contract.\n    // * This can only be done by owners\n    function setBeerTokenContractAddress(address addr) external;\n    // * Show which beer is served\n    function beerTokenContractAddress() external view returns(address);\n\n    // * The bar has opening hours during which beer can be ordered and served\n    // * The bar is opened and closed by barkeepers\n    function openBar() external;\n    function closeBar() external;\n    function barIsOpen() external view returns (bool);\n    event BarOpened();\n    event BarClosed();\n\n    // * When new beer is delivered, the token contract owner mints new\n    //   tokens and transfers them to the bar contract with the string\n    //   \"supply\" in the data field (since this is not a beer order)\n    // * The bar contract emits the event BeerSupplied when receiving\n    //   beer tokens marked as \"supply\" (together with beer)\n    event BeerSupplied(address indexed from, uint256 amount);\n\n    // * Beer is ordered by transferring beer tokens to the bar contract\n    //   with the data field \"hex\"00000000\" (standard transfer);\n    //   1 token = 1 beer\n    // * Beer can only be ordered while the bar is open\n    // * In addition to the internal bookkeeping, the event\n    //   BeerOrdered is triggered to signal that there is work\n    event BeerOrdered(address indexed customer, uint256 amount);\n\n    // Both, supply and order, have to be implemented in a token fallback function\n\n    // * Beer that has been ordered will be served by barkeepers\n    // * Beer can only be served while the bar is open\n    // * Served beer has to be burned by the token contract\n    function serveBeer(address customer, uint amount) external;\n\n    // * Orders that haven't yet been processed may be canceled by the\n    //   customer, who will get back the tokens\n    // * This triggers the event BeerCanceled\n    // * Orders can be canceled at any time\n    function cancelOrder(uint amount) external;\n    event BeerCanceled(address indexed customer, uint256 amount);\n\n    // * Get pending orders for a customer\n    function pendingBeer(address customer) external view returns (uint256);\n\n    // * Beer price can only be changed by owners when the bar is closed\n    function setBeerPrice(uint256 price) external;\n    function getBeerPrice() external view returns(uint256);\n\n    // * Customers may buy tokens for Ether\n    // * If the supplied Ether is not divisible by the beer price\n    //   the rest is kept as a tip. The caller (like the web interface)\n    //   can check that the value is a multiple of the beer price.\n    function buyToken() external payable;\n\n    // * `amount` (in Wei) of the Ether stored in the contract is transferred to\n    //   `receiver`, provided `amount` does not exceed the balance of the contract\n    // * Only owners are allowed to do this\n    function payout(address payable receiver, uint256 amount) external;\n\n}\n"
    },
    "contracts/Address.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return payable(account);\r\n    }\r\n}"
    },
    "contracts/IBeerToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBeerToken {\n\n    // * Default attributes of your token\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n\n    // * Our BeerToken is not divisible\n    function decimals() external view returns (uint8);\n\n    // * Show the total supply of tokens\n    function totalSupply() external view returns (uint256);\n    // * Show the token balance of the address\n    function balanceOf(address who) external view returns (uint256);\n\n    // * Basic functionality for transferring tokens to user.\n    //   The token contract keeps track of the token balances.\n    // * Token must not be lost! Make sure they can only be transferred to addresses,\n    //   who also support the receiving of tokens.\n    function transfer(address to, uint256 value) external returns (bool success);\n    function transfer(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n    // * Tokens can be minted by the owner of the token contract\n    function mint(address account, uint256 value) external returns (bool success);\n\n    // * Tokens can be burned and therefore \"destroyed\"\n    function burn(uint256 value) external;\n\n    // * Everytime a token is transferred/balances changed, this event has to be emitted\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n}"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  }
}